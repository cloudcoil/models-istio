# Generated by cloudcoil-model-codegen v0.5.5
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Port(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Port"]:
            return Port

        def build(self) -> "Port":
            return Port(**self._attrs)

        def number(self, value: int, /) -> Self:
            return self._set("number", value)

    class BuilderContext(BuilderContextBase["Port.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Port.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Port."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Port", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Port.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    number: Annotated[int, Field(ge=1, le=65535)]


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        def mode(
            self,
            value: Optional[Literal["UNDEFINED", "CLIENT", "SERVER", "CLIENT_AND_SERVER"]],
            /,
        ) -> Self:
            """
            Criteria for selecting traffic by their direction.

            Valid Options: CLIENT, SERVER, CLIENT_AND_SERVER
            """
            return self._set("mode", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "Match.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            Criteria for selecting traffic by their destination port.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["UNDEFINED", "CLIENT", "SERVER", "CLIENT_AND_SERVER"]] = None
    """
    Criteria for selecting traffic by their direction.

    Valid Options: CLIENT, SERVER, CLIENT_AND_SERVER
    """
    ports: Optional[List[Port]] = None
    """
    Criteria for selecting traffic by their destination port.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
    """


class TargetRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TargetRef"]:
            return TargetRef

        def build(self) -> "TargetRef":
            return TargetRef(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            """
            group is the group of the target resource.
            """
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            """
            kind is kind of the target resource.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            name is the name of the target resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            namespace is the namespace of the referent.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["TargetRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TargetRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TargetRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TargetRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TargetRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Annotated[
        Optional[str],
        Field(
            max_length=253,
            pattern="^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ] = None
    """
    group is the group of the target resource.
    """
    kind: Annotated[
        str,
        Field(max_length=63, min_length=1, pattern="^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"),
    ]
    """
    kind is kind of the target resource.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    name is the name of the target resource.
    """
    namespace: Optional[str] = None
    """
    namespace is the namespace of the referent.
    """


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the environment variable.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value for the environment variable.
            """
            return self._set("value", value)

        def value_from(self, value: Optional[Literal["INLINE", "HOST"]], /) -> Self:
            """
            Source for the environment variable's value.

            Valid Options: INLINE, HOST
            """
            return self._set("value_from", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(max_length=256, min_length=1)]
    """
    Name of the environment variable.
    """
    value: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    Value for the environment variable.
    """
    value_from: Annotated[Optional[Literal["INLINE", "HOST"]], Field(alias="valueFrom")] = None
    """
    Source for the environment variable's value.

    Valid Options: INLINE, HOST
    """


class VmConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VmConfig"]:
            return VmConfig

        def build(self) -> "VmConfig":
            return VmConfig(**self._attrs)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "VmConfig.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "VmConfig.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            Specifies environment variables to be injected to this VM.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

    class BuilderContext(BuilderContextBase["VmConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VmConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VmConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VmConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VmConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env: Annotated[Optional[List[Env]], Field(max_length=256)] = None
    """
    Specifies environment variables to be injected to this VM.
    """


class WasmPluginSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WasmPluginSpec"]:
            return WasmPluginSpec

        def build(self) -> "WasmPluginSpec":
            return WasmPluginSpec(**self._attrs)

        def fail_strategy(self, value: Optional[Literal["FAIL_CLOSE", "FAIL_OPEN"]], /) -> Self:
            """
            Specifies the failure behavior for the plugin due to fatal errors.

            Valid Options: FAIL_CLOSE, FAIL_OPEN
            """
            return self._set("fail_strategy", value)

        def image_pull_policy(
            self,
            value: Optional[Literal["UNSPECIFIED_POLICY", "IfNotPresent", "Always"]],
            /,
        ) -> Self:
            """
            The pull behaviour to be applied when fetching Wasm module by either OCI image or `http/https`.

            Valid Options: IfNotPresent, Always
            """
            return self._set("image_pull_policy", value)

        def image_pull_secret(self, value: Optional[str], /) -> Self:
            """
            Credentials to use for OCI image pulling.
            """
            return self._set("image_pull_secret", value)

        @overload
        def match(self, value_or_callback: List[Match], /) -> "WasmPluginSpec.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Match, Match.Builder]],
                GenericListBuilder[Match, Match.Builder] | List[Match],
            ],
            /,
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> ListBuilderContext[Match.Builder]: ...

        def match(self, value_or_callback=None, /):
            """
            Specifies the criteria to determine which traffic is passed to WasmPlugin.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Match.Builder]()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        def phase(
            self,
            value: Optional[Literal["UNSPECIFIED_PHASE", "AUTHN", "AUTHZ", "STATS"]],
            /,
        ) -> Self:
            """
            Determines where in the filter chain this `WasmPlugin` is to be injected.

            Valid Options: AUTHN, AUTHZ, STATS
            """
            return self._set("phase", value)

        def plugin_config(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            The configuration that will be passed on to the plugin.
            """
            return self._set("plugin_config", value)

        def plugin_name(self, value: Optional[str], /) -> Self:
            """
            The plugin name to be used in the Envoy configuration (used to be called `rootID`).
            """
            return self._set("plugin_name", value)

        def priority(self, value: Optional[int], /) -> Self:
            """
            Determines ordering of `WasmPlugins` in the same `phase`.
            """
            return self._set("priority", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def sha256(self, value: Optional[str], /) -> Self:
            """
            SHA256 checksum that will be used to verify Wasm module or OCI container.
            """
            return self._set("sha256", value)

        @overload
        def target_ref(
            self, value_or_callback: Optional[TargetRef], /
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def target_ref(
            self,
            value_or_callback: Callable[[TargetRef.Builder], TargetRef.Builder | TargetRef],
            /,
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def target_ref(self, value_or_callback: Never = ...) -> "TargetRef.BuilderContext": ...

        def target_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.builder())
                if isinstance(output, TargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_ref", value)

        @overload
        def target_refs(
            self, value_or_callback: List[TargetRef], /
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def target_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetRef, TargetRef.Builder]],
                GenericListBuilder[TargetRef, TargetRef.Builder] | List[TargetRef],
            ],
            /,
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def target_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetRef.Builder]: ...

        def target_refs(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetRef.Builder]()
                context._parent_builder = self
                context._field_name = "target_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_refs", value)

        def type(
            self,
            value: Optional[Literal["UNSPECIFIED_PLUGIN_TYPE", "HTTP", "NETWORK"]],
            /,
        ) -> Self:
            """
            Specifies the type of Wasm Extension to be used.

            Valid Options: HTTP, NETWORK
            """
            return self._set("type", value)

        def url(self, value: str, /) -> Self:
            """
            URL of a Wasm module or OCI container.
            """
            return self._set("url", value)

        def verification_key(self, value: Optional[str], /) -> Self:
            return self._set("verification_key", value)

        @overload
        def vm_config(
            self, value_or_callback: Optional[VmConfig], /
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def vm_config(
            self,
            value_or_callback: Callable[[VmConfig.Builder], VmConfig.Builder | VmConfig],
            /,
        ) -> "WasmPluginSpec.Builder": ...

        @overload
        def vm_config(self, value_or_callback: Never = ...) -> "VmConfig.BuilderContext": ...

        def vm_config(self, value_or_callback=None, /):
            """
            Configuration for a Wasm VM.
            """
            if self._in_context and value_or_callback is None:
                context = VmConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "vm_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VmConfig.builder())
                if isinstance(output, VmConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vm_config", value)

    class BuilderContext(BuilderContextBase["WasmPluginSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WasmPluginSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WasmPluginSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WasmPluginSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WasmPluginSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fail_strategy: Annotated[
        Optional[Literal["FAIL_CLOSE", "FAIL_OPEN"]], Field(alias="failStrategy")
    ] = None
    """
    Specifies the failure behavior for the plugin due to fatal errors.

    Valid Options: FAIL_CLOSE, FAIL_OPEN
    """
    image_pull_policy: Annotated[
        Optional[Literal["UNSPECIFIED_POLICY", "IfNotPresent", "Always"]],
        Field(alias="imagePullPolicy"),
    ] = None
    """
    The pull behaviour to be applied when fetching Wasm module by either OCI image or `http/https`.

    Valid Options: IfNotPresent, Always
    """
    image_pull_secret: Annotated[
        Optional[str], Field(alias="imagePullSecret", max_length=253, min_length=1)
    ] = None
    """
    Credentials to use for OCI image pulling.
    """
    match: Optional[List[Match]] = None
    """
    Specifies the criteria to determine which traffic is passed to WasmPlugin.
    """
    phase: Optional[Literal["UNSPECIFIED_PHASE", "AUTHN", "AUTHZ", "STATS"]] = None
    """
    Determines where in the filter chain this `WasmPlugin` is to be injected.

    Valid Options: AUTHN, AUTHZ, STATS
    """
    plugin_config: Annotated[Optional[Dict[str, Any]], Field(alias="pluginConfig")] = None
    """
    The configuration that will be passed on to the plugin.
    """
    plugin_name: Annotated[
        Optional[str], Field(alias="pluginName", max_length=256, min_length=1)
    ] = None
    """
    The plugin name to be used in the Envoy configuration (used to be called `rootID`).
    """
    priority: Optional[int] = None
    """
    Determines ordering of `WasmPlugins` in the same `phase`.
    """
    selector: Optional[Selector] = None
    """
    Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied.
    """
    sha256: Annotated[Optional[str], Field(pattern="(^$|^[a-f0-9]{64}$)")] = None
    """
    SHA256 checksum that will be used to verify Wasm module or OCI container.
    """
    target_ref: Annotated[Optional[TargetRef], Field(alias="targetRef")] = None
    target_refs: Annotated[Optional[List[TargetRef]], Field(alias="targetRefs", max_length=16)] = (
        None
    )
    """
    Optional.
    """
    type: Optional[Literal["UNSPECIFIED_PLUGIN_TYPE", "HTTP", "NETWORK"]] = None
    """
    Specifies the type of Wasm Extension to be used.

    Valid Options: HTTP, NETWORK
    """
    url: Annotated[str, Field(min_length=1)]
    """
    URL of a Wasm module or OCI container.
    """
    verification_key: Annotated[Optional[str], Field(alias="verificationKey")] = None
    vm_config: Annotated[Optional[VmConfig], Field(alias="vmConfig")] = None
    """
    Configuration for a Wasm VM.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Unique, one-word, CamelCase reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the type of the condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    Last time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    Last time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    Unique, one-word, CamelCase reason for the condition's last transition.
    """
    status: Optional[str] = None
    """
    Status is the status of the condition.
    """
    type: Optional[str] = None
    """
    Type is the type of the condition.
    """


class MessageType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MessageType"]:
            return MessageType

        def build(self) -> "MessageType":
            return MessageType(**self._attrs)

        def code(self, value: Optional[str], /) -> Self:
            """
            A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
            """
            return self._set("code", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            A human-readable name for the message type.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["MessageType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MessageType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MessageType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MessageType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MessageType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    code: Optional[str] = None
    """
    A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
    """
    name: Optional[str] = None
    """
    A human-readable name for the message type.
    """


class ValidationMessage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValidationMessage"]:
            return ValidationMessage

        def build(self) -> "ValidationMessage":
            return ValidationMessage(**self._attrs)

        def documentation_url(self, value: Optional[str], /) -> Self:
            """
            A url pointing to the Istio documentation for this specific error type.
            """
            return self._set("documentation_url", value)

        def level(self, value: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]], /) -> Self:
            """
            Represents how severe a message is.

            Valid Options: UNKNOWN, ERROR, WARNING, INFO
            """
            return self._set("level", value)

        @overload
        def type(
            self, value_or_callback: Optional[MessageType], /
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(
            self,
            value_or_callback: Callable[[MessageType.Builder], MessageType.Builder | MessageType],
            /,
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(self, value_or_callback: Never = ...) -> "MessageType.BuilderContext": ...

        def type(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MessageType.BuilderContext()
                context._parent_builder = self
                context._field_name = "type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MessageType.builder())
                if isinstance(output, MessageType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ValidationMessage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValidationMessage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValidationMessage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValidationMessage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValidationMessage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    documentation_url: Annotated[Optional[str], Field(alias="documentationUrl")] = None
    """
    A url pointing to the Istio documentation for this specific error type.
    """
    level: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]] = None
    """
    Represents how severe a message is.

    Valid Options: UNKNOWN, ERROR, WARNING, INFO
    """
    type: Annotated[
        Optional[MessageType],
        Field(title="cloudcoil.models.istio.extensions.v1alpha1.MessageType"),
    ] = None


class WasmPluginStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WasmPluginStatus"]:
            return WasmPluginStatus

        def build(self) -> "WasmPluginStatus":
            return WasmPluginStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "WasmPluginStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "WasmPluginStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "WasmPluginStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "WasmPluginStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["WasmPluginStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WasmPluginStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WasmPluginStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WasmPluginStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WasmPluginStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class WasmPlugin(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WasmPlugin"]:
            return WasmPlugin

        def build(self) -> "WasmPlugin":
            return WasmPlugin(**self._attrs)

        @overload
        def spec(self, value_or_callback: WasmPluginSpec, /) -> "WasmPlugin.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [WasmPluginSpec.Builder], WasmPluginSpec.Builder | WasmPluginSpec
            ],
            /,
        ) -> "WasmPlugin.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "WasmPluginSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WasmPluginSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WasmPluginSpec.builder())
                if isinstance(output, WasmPluginSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[WasmPluginStatus], /
        ) -> "WasmPlugin.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [WasmPluginStatus.Builder], WasmPluginStatus.Builder | WasmPluginStatus
            ],
            /,
        ) -> "WasmPlugin.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "WasmPluginStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WasmPluginStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WasmPluginStatus.builder())
                if isinstance(output, WasmPluginStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["extensions.istio.io/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["WasmPlugin"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "WasmPlugin.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "WasmPlugin.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["WasmPlugin.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WasmPlugin.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WasmPlugin."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WasmPlugin", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WasmPlugin.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: WasmPluginSpec
    status: Optional[WasmPluginStatus] = None
    api_version: Annotated[
        Optional[Literal["extensions.istio.io/v1alpha1"]], Field(alias="apiVersion")
    ] = "extensions.istio.io/v1alpha1"
    kind: Optional[Literal["WasmPlugin"]] = "WasmPlugin"
    metadata: Optional[apimachinery.ObjectMeta] = None
