# Generated by cloudcoil-model-codegen v0.5.0
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from pydantic import Field, RootModel

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Provider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Provider"]:
            return Provider

        def build(self) -> "Provider":
            return Provider(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Specifies the name of the extension provider.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Provider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Provider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Provider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Provider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Provider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    Specifies the name of the extension provider.
    """


class Source(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Source"]:
            return Source

        def build(self) -> "Source":
            return Source(**self._attrs)

        def ip_blocks(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("ip_blocks", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("namespaces", value)

        def not_ip_blocks(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_ip_blocks", value)

        def not_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_namespaces", value)

        def not_principals(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_principals", value)

        def not_remote_ip_blocks(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_remote_ip_blocks", value)

        def not_request_principals(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_request_principals", value)

        def principals(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("principals", value)

        def remote_ip_blocks(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("remote_ip_blocks", value)

        def request_principals(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("request_principals", value)

    class BuilderContext(BuilderContextBase["Source.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Source.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Source."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Source", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Source.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ip_blocks: Annotated[Optional[List[str]], Field(alias="ipBlocks")] = None
    """
    Optional.
    """
    namespaces: Optional[List[str]] = None
    """
    Optional.
    """
    not_ip_blocks: Annotated[Optional[List[str]], Field(alias="notIpBlocks")] = None
    """
    Optional.
    """
    not_namespaces: Annotated[Optional[List[str]], Field(alias="notNamespaces")] = None
    """
    Optional.
    """
    not_principals: Annotated[Optional[List[str]], Field(alias="notPrincipals")] = None
    """
    Optional.
    """
    not_remote_ip_blocks: Annotated[Optional[List[str]], Field(alias="notRemoteIpBlocks")] = None
    """
    Optional.
    """
    not_request_principals: Annotated[Optional[List[str]], Field(alias="notRequestPrincipals")] = (
        None
    )
    """
    Optional.
    """
    principals: Optional[List[str]] = None
    """
    Optional.
    """
    remote_ip_blocks: Annotated[Optional[List[str]], Field(alias="remoteIpBlocks")] = None
    """
    Optional.
    """
    request_principals: Annotated[Optional[List[str]], Field(alias="requestPrincipals")] = None
    """
    Optional.
    """


class From(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["From"]:
            return From

        def build(self) -> "From":
            return From(**self._attrs)

        @overload
        def source(self, value_or_callback: Optional[Source], /) -> "From.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[[Source.Builder], Source.Builder | Source],
            /,
        ) -> "From.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "Source.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            """
            Source specifies the source of a request.
            """
            if self._in_context and value_or_callback is None:
                context = Source.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Source.builder())
                if isinstance(output, Source.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["From.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = From.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for From."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["From", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use From.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source: Optional[Source] = None
    """
    Source specifies the source of a request.
    """


class Operation(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Operation"]:
            return Operation

        def build(self) -> "Operation":
            return Operation(**self._attrs)

        def hosts(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("hosts", value)

        def methods(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("methods", value)

        def not_hosts(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_hosts", value)

        def not_methods(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_methods", value)

        def not_paths(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_paths", value)

        def not_ports(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_ports", value)

        def paths(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("paths", value)

        def ports(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("ports", value)

    class BuilderContext(BuilderContextBase["Operation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Operation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Operation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Operation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Operation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hosts: Optional[List[str]] = None
    """
    Optional.
    """
    methods: Optional[List[str]] = None
    """
    Optional.
    """
    not_hosts: Annotated[Optional[List[str]], Field(alias="notHosts")] = None
    """
    Optional.
    """
    not_methods: Annotated[Optional[List[str]], Field(alias="notMethods")] = None
    """
    Optional.
    """
    not_paths: Annotated[Optional[List[str]], Field(alias="notPaths")] = None
    """
    Optional.
    """
    not_ports: Annotated[Optional[List[str]], Field(alias="notPorts")] = None
    """
    Optional.
    """
    paths: Optional[List[str]] = None
    """
    Optional.
    """
    ports: Optional[List[str]] = None
    """
    Optional.
    """


class To(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["To"]:
            return To

        def build(self) -> "To":
            return To(**self._attrs)

        @overload
        def operation(self, value_or_callback: Optional[Operation], /) -> "To.Builder": ...

        @overload
        def operation(
            self,
            value_or_callback: Callable[[Operation.Builder], Operation.Builder | Operation],
            /,
        ) -> "To.Builder": ...

        @overload
        def operation(self, value_or_callback: Never = ...) -> "Operation.BuilderContext": ...

        def operation(self, value_or_callback=None, /):
            """
            Operation specifies the operation of a request.
            """
            if self._in_context and value_or_callback is None:
                context = Operation.BuilderContext()
                context._parent_builder = self
                context._field_name = "operation"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Operation.builder())
                if isinstance(output, Operation.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("operation", value)

    class BuilderContext(BuilderContextBase["To.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = To.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for To."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["To", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use To.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    operation: Optional[Operation] = None
    """
    Operation specifies the operation of a request.
    """


class When(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["When"]:
            return When

        def build(self) -> "When":
            return When(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The name of an Istio attribute.
            """
            return self._set("key", value)

        def not_values(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("not_values", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Optional.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["When.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = When.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for When."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["When", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use When.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The name of an Istio attribute.
    """
    not_values: Annotated[Optional[List[str]], Field(alias="notValues")] = None
    """
    Optional.
    """
    values: Optional[List[str]] = None
    """
    Optional.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        @overload
        def from_(self, value_or_callback: List[From], /) -> "Rule.Builder": ...

        @overload
        def from_(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[From, From.Builder]],
                GenericListBuilder[From, From.Builder] | List[From],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def from_(self, value_or_callback: Never = ...) -> ListBuilderContext[From.Builder]: ...

        def from_(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[From.Builder]()
                context._parent_builder = self
                context._field_name = "from_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(From.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("from_", value)

        @overload
        def to(self, value_or_callback: List[To], /) -> "Rule.Builder": ...

        @overload
        def to(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[To, To.Builder]],
                GenericListBuilder[To, To.Builder] | List[To],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def to(self, value_or_callback: Never = ...) -> ListBuilderContext[To.Builder]: ...

        def to(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[To.Builder]()
                context._parent_builder = self
                context._field_name = "to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(To.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("to", value)

        @overload
        def when(self, value_or_callback: List[When], /) -> "Rule.Builder": ...

        @overload
        def when(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[When, When.Builder]],
                GenericListBuilder[When, When.Builder] | List[When],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def when(self, value_or_callback: Never = ...) -> ListBuilderContext[When.Builder]: ...

        def when(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[When.Builder]()
                context._parent_builder = self
                context._field_name = "when"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(When.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("when", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_: Annotated[Optional[List[From]], Field(alias="from")] = None
    """
    Optional.
    """
    to: Optional[List[To]] = None
    """
    Optional.
    """
    when: Optional[List[When]] = None
    """
    Optional.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
    """


class TargetRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TargetRef"]:
            return TargetRef

        def build(self) -> "TargetRef":
            return TargetRef(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            """
            group is the group of the target resource.
            """
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            """
            kind is kind of the target resource.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            name is the name of the target resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            namespace is the namespace of the referent.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["TargetRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TargetRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TargetRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TargetRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TargetRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Annotated[
        Optional[str],
        Field(
            max_length=253,
            pattern="^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ] = None
    """
    group is the group of the target resource.
    """
    kind: Annotated[
        str,
        Field(max_length=63, min_length=1, pattern="^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"),
    ]
    """
    kind is kind of the target resource.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    name is the name of the target resource.
    """
    namespace: Optional[str] = None
    """
    namespace is the namespace of the referent.
    """


class AuthorizationPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationPolicySpec"]:
            return AuthorizationPolicySpec

        def build(self) -> "AuthorizationPolicySpec":
            return AuthorizationPolicySpec(**self._attrs)

        def action(self, value: Optional[Literal["ALLOW", "DENY", "AUDIT", "CUSTOM"]], /) -> Self:
            """
            Optional.

            Valid Options: ALLOW, DENY, AUDIT, CUSTOM
            """
            return self._set("action", value)

        @overload
        def provider(
            self, value_or_callback: Optional[Provider], /
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def provider(
            self,
            value_or_callback: Callable[[Provider.Builder], Provider.Builder | Provider],
            /,
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def provider(self, value_or_callback: Never = ...) -> "Provider.BuilderContext": ...

        def provider(self, value_or_callback=None, /):
            """
            Specifies detailed configuration of the CUSTOM action.
            """
            if self._in_context and value_or_callback is None:
                context = Provider.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Provider.builder())
                if isinstance(output, Provider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider", value)

        @overload
        def rules(self, value_or_callback: List[Rule], /) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        @overload
        def target_ref(
            self, value_or_callback: Optional[TargetRef], /
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def target_ref(
            self,
            value_or_callback: Callable[[TargetRef.Builder], TargetRef.Builder | TargetRef],
            /,
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def target_ref(self, value_or_callback: Never = ...) -> "TargetRef.BuilderContext": ...

        def target_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.builder())
                if isinstance(output, TargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_ref", value)

        @overload
        def target_refs(
            self, value_or_callback: List[TargetRef], /
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def target_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetRef, TargetRef.Builder]],
                GenericListBuilder[TargetRef, TargetRef.Builder] | List[TargetRef],
            ],
            /,
        ) -> "AuthorizationPolicySpec.Builder": ...

        @overload
        def target_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetRef.Builder]: ...

        def target_refs(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetRef.Builder]()
                context._parent_builder = self
                context._field_name = "target_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_refs", value)

    class BuilderContext(BuilderContextBase["AuthorizationPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[Literal["ALLOW", "DENY", "AUDIT", "CUSTOM"]] = None
    """
    Optional.

    Valid Options: ALLOW, DENY, AUDIT, CUSTOM
    """
    provider: Optional[Provider] = None
    """
    Specifies detailed configuration of the CUSTOM action.
    """
    rules: Optional[List[Rule]] = None
    """
    Optional.
    """
    selector: Optional[Selector] = None
    """
    Optional.
    """
    target_ref: Annotated[Optional[TargetRef], Field(alias="targetRef")] = None
    target_refs: Annotated[Optional[List[TargetRef]], Field(alias="targetRefs", max_length=16)] = (
        None
    )
    """
    Optional.
    """


class AuthorizationPolicySpecModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationPolicySpecModel"]:
            return AuthorizationPolicySpecModel

        def build(self) -> "AuthorizationPolicySpecModel":
            return AuthorizationPolicySpecModel(**self._attrs)

        def action(self, value: Optional[Literal["ALLOW", "DENY", "AUDIT", "CUSTOM"]], /) -> Self:
            """
            Optional.

            Valid Options: ALLOW, DENY, AUDIT, CUSTOM
            """
            return self._set("action", value)

        @overload
        def provider(
            self, value_or_callback: Provider, /
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def provider(
            self,
            value_or_callback: Callable[[Provider.Builder], Provider.Builder | Provider],
            /,
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def provider(self, value_or_callback: Never = ...) -> "Provider.BuilderContext": ...

        def provider(self, value_or_callback=None, /):
            """
            Specifies detailed configuration of the CUSTOM action.
            """
            if self._in_context and value_or_callback is None:
                context = Provider.BuilderContext()
                context._parent_builder = self
                context._field_name = "provider"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Provider.builder())
                if isinstance(output, Provider.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("provider", value)

        @overload
        def rules(
            self, value_or_callback: List[Rule], /
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        @overload
        def target_ref(
            self, value_or_callback: Optional[TargetRef], /
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def target_ref(
            self,
            value_or_callback: Callable[[TargetRef.Builder], TargetRef.Builder | TargetRef],
            /,
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def target_ref(self, value_or_callback: Never = ...) -> "TargetRef.BuilderContext": ...

        def target_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.builder())
                if isinstance(output, TargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_ref", value)

        @overload
        def target_refs(
            self, value_or_callback: List[TargetRef], /
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def target_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetRef, TargetRef.Builder]],
                GenericListBuilder[TargetRef, TargetRef.Builder] | List[TargetRef],
            ],
            /,
        ) -> "AuthorizationPolicySpecModel.Builder": ...

        @overload
        def target_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetRef.Builder]: ...

        def target_refs(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetRef.Builder]()
                context._parent_builder = self
                context._field_name = "target_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_refs", value)

    class BuilderContext(BuilderContextBase["AuthorizationPolicySpecModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationPolicySpecModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationPolicySpecModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationPolicySpecModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationPolicySpecModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[Literal["ALLOW", "DENY", "AUDIT", "CUSTOM"]] = None
    """
    Optional.

    Valid Options: ALLOW, DENY, AUDIT, CUSTOM
    """
    provider: Provider
    """
    Specifies detailed configuration of the CUSTOM action.
    """
    rules: Optional[List[Rule]] = None
    """
    Optional.
    """
    selector: Optional[Selector] = None
    """
    Optional.
    """
    target_ref: Annotated[Optional[TargetRef], Field(alias="targetRef")] = None
    target_refs: Annotated[Optional[List[TargetRef]], Field(alias="targetRefs", max_length=16)] = (
        None
    )
    """
    Optional.
    """


class AuthorizationPolicySpecModel1(
    RootModel[Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel]]
):
    class Builder(BaseBuilder):
        _value: Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel] | None = None

        def root(
            self, value: Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel], /
        ) -> Self:
            """
            Configuration for access control on workloads. See more details at: https://istio.io/docs/reference/config/security/authorization-policy.html
            """
            self._value = value
            return self

        def __call__(
            self, value: Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel], /
        ) -> Self:
            """
            Configuration for access control on workloads. See more details at: https://istio.io/docs/reference/config/security/authorization-policy.html
            """
            self._value = value
            return self

        def build(self) -> "AuthorizationPolicySpecModel1":
            value = cast(
                Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel],
                self._value,
            )
            return AuthorizationPolicySpecModel1(value)

    root: Union[AuthorizationPolicySpec, AuthorizationPolicySpecModel]
    """
    Configuration for access control on workloads. See more details at: https://istio.io/docs/reference/config/security/authorization-policy.html
    """

    class BuilderContext(BuilderContextBase["AuthorizationPolicySpecModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationPolicySpecModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationPolicySpecModel1."""
        return cls.BuilderContext()


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Unique, one-word, CamelCase reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the type of the condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    Last time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    Last time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    Unique, one-word, CamelCase reason for the condition's last transition.
    """
    status: Optional[str] = None
    """
    Status is the status of the condition.
    """
    type: Optional[str] = None
    """
    Type is the type of the condition.
    """


class MessageType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MessageType"]:
            return MessageType

        def build(self) -> "MessageType":
            return MessageType(**self._attrs)

        def code(self, value: Optional[str], /) -> Self:
            """
            A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
            """
            return self._set("code", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            A human-readable name for the message type.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["MessageType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MessageType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MessageType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MessageType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MessageType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    code: Optional[str] = None
    """
    A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
    """
    name: Optional[str] = None
    """
    A human-readable name for the message type.
    """


class ValidationMessage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValidationMessage"]:
            return ValidationMessage

        def build(self) -> "ValidationMessage":
            return ValidationMessage(**self._attrs)

        def documentation_url(self, value: Optional[str], /) -> Self:
            """
            A url pointing to the Istio documentation for this specific error type.
            """
            return self._set("documentation_url", value)

        def level(self, value: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]], /) -> Self:
            """
            Represents how severe a message is.

            Valid Options: UNKNOWN, ERROR, WARNING, INFO
            """
            return self._set("level", value)

        @overload
        def type(
            self, value_or_callback: Optional[MessageType], /
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(
            self,
            value_or_callback: Callable[[MessageType.Builder], MessageType.Builder | MessageType],
            /,
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(self, value_or_callback: Never = ...) -> "MessageType.BuilderContext": ...

        def type(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MessageType.BuilderContext()
                context._parent_builder = self
                context._field_name = "type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MessageType.builder())
                if isinstance(output, MessageType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ValidationMessage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValidationMessage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValidationMessage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValidationMessage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValidationMessage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    documentation_url: Annotated[Optional[str], Field(alias="documentationUrl")] = None
    """
    A url pointing to the Istio documentation for this specific error type.
    """
    level: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]] = None
    """
    Represents how severe a message is.

    Valid Options: UNKNOWN, ERROR, WARNING, INFO
    """
    type: Annotated[
        Optional[MessageType],
        Field(title="cloudcoil.models.istio.security.v1.MessageType"),
    ] = None


class AuthorizationPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationPolicyStatus"]:
            return AuthorizationPolicyStatus

        def build(self) -> "AuthorizationPolicyStatus":
            return AuthorizationPolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "AuthorizationPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "AuthorizationPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "AuthorizationPolicyStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "AuthorizationPolicyStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["AuthorizationPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class Mtls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Mtls"]:
            return Mtls

        def build(self) -> "Mtls":
            return Mtls(**self._attrs)

        def mode(
            self,
            value: Optional[Literal["UNSET", "DISABLE", "PERMISSIVE", "STRICT"]],
            /,
        ) -> Self:
            """
            Defines the mTLS mode used for peer authentication.

            Valid Options: DISABLE, PERMISSIVE, STRICT
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["Mtls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Mtls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Mtls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Mtls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Mtls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["UNSET", "DISABLE", "PERMISSIVE", "STRICT"]] = None
    """
    Defines the mTLS mode used for peer authentication.

    Valid Options: DISABLE, PERMISSIVE, STRICT
    """


class PortLevelMtls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortLevelMtls"]:
            return PortLevelMtls

        def build(self) -> "PortLevelMtls":
            return PortLevelMtls(**self._attrs)

        def mode(
            self,
            value: Optional[Literal["UNSET", "DISABLE", "PERMISSIVE", "STRICT"]],
            /,
        ) -> Self:
            """
            Defines the mTLS mode used for peer authentication.

            Valid Options: DISABLE, PERMISSIVE, STRICT
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["PortLevelMtls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortLevelMtls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortLevelMtls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortLevelMtls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortLevelMtls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["UNSET", "DISABLE", "PERMISSIVE", "STRICT"]] = None
    """
    Defines the mTLS mode used for peer authentication.

    Valid Options: DISABLE, PERMISSIVE, STRICT
    """


class PeerAuthenticationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PeerAuthenticationSpec"]:
            return PeerAuthenticationSpec

        def build(self) -> "PeerAuthenticationSpec":
            return PeerAuthenticationSpec(**self._attrs)

        @overload
        def mtls(
            self, value_or_callback: Optional[Mtls], /
        ) -> "PeerAuthenticationSpec.Builder": ...

        @overload
        def mtls(
            self, value_or_callback: Callable[[Mtls.Builder], Mtls.Builder | Mtls], /
        ) -> "PeerAuthenticationSpec.Builder": ...

        @overload
        def mtls(self, value_or_callback: Never = ...) -> "Mtls.BuilderContext": ...

        def mtls(self, value_or_callback=None, /):
            """
            Mutual TLS settings for workload.
            """
            if self._in_context and value_or_callback is None:
                context = Mtls.BuilderContext()
                context._parent_builder = self
                context._field_name = "mtls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mtls.builder())
                if isinstance(output, Mtls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mtls", value)

        def port_level_mtls(self, value: Optional[Dict[str, PortLevelMtls]], /) -> Self:
            """
            Port specific mutual TLS settings.
            """
            return self._set("port_level_mtls", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "PeerAuthenticationSpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "PeerAuthenticationSpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            The selector determines the workloads to apply the PeerAuthentication on.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["PeerAuthenticationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PeerAuthenticationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PeerAuthenticationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PeerAuthenticationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PeerAuthenticationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mtls: Optional[Mtls] = None
    """
    Mutual TLS settings for workload.
    """
    port_level_mtls: Annotated[Optional[Dict[str, PortLevelMtls]], Field(alias="portLevelMtls")] = (
        None
    )
    """
    Port specific mutual TLS settings.
    """
    selector: Optional[Selector] = None
    """
    The selector determines the workloads to apply the PeerAuthentication on.
    """


class PeerAuthenticationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PeerAuthenticationStatus"]:
            return PeerAuthenticationStatus

        def build(self) -> "PeerAuthenticationStatus":
            return PeerAuthenticationStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "PeerAuthenticationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "PeerAuthenticationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "PeerAuthenticationStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "PeerAuthenticationStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["PeerAuthenticationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PeerAuthenticationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PeerAuthenticationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PeerAuthenticationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PeerAuthenticationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class Audience(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Audience":
            value = cast(str, self._value)
            return Audience(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Audience.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Audience.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Audience."""
        return cls.BuilderContext()


class FromCooky(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "FromCooky":
            value = cast(str, self._value)
            return FromCooky(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["FromCooky.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FromCooky.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FromCooky."""
        return cls.BuilderContext()


class FromHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FromHeader"]:
            return FromHeader

        def build(self) -> "FromHeader":
            return FromHeader(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            The HTTP header name.
            """
            return self._set("name", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            The prefix that should be stripped before decoding the token.
            """
            return self._set("prefix", value)

    class BuilderContext(BuilderContextBase["FromHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FromHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FromHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FromHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FromHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    The HTTP header name.
    """
    prefix: Optional[str] = None
    """
    The prefix that should be stripped before decoding the token.
    """


class FromParam(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "FromParam":
            value = cast(str, self._value)
            return FromParam(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["FromParam.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FromParam.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FromParam."""
        return cls.BuilderContext()


class OutputClaimToHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OutputClaimToHeader"]:
            return OutputClaimToHeader

        def build(self) -> "OutputClaimToHeader":
            return OutputClaimToHeader(**self._attrs)

        def claim(self, value: str, /) -> Self:
            """
            The name of the claim to be copied from.
            """
            return self._set("claim", value)

        def header(self, value: str, /) -> Self:
            """
            The name of the header to be created.
            """
            return self._set("header", value)

    class BuilderContext(BuilderContextBase["OutputClaimToHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OutputClaimToHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OutputClaimToHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OutputClaimToHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OutputClaimToHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claim: Annotated[str, Field(min_length=1)]
    """
    The name of the claim to be copied from.
    """
    header: Annotated[str, Field(min_length=1, pattern="^[-_A-Za-z0-9]+$")]
    """
    The name of the header to be created.
    """


class JwtRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["JwtRule"]:
            return JwtRule

        def build(self) -> "JwtRule":
            return JwtRule(**self._attrs)

        @overload
        def audiences(self, value_or_callback: List[Audience], /) -> "JwtRule.Builder": ...

        @overload
        def audiences(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Audience, Audience.Builder]],
                GenericListBuilder[Audience, Audience.Builder] | List[Audience],
            ],
            /,
        ) -> "JwtRule.Builder": ...

        @overload
        def audiences(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Audience.Builder]: ...

        def audiences(self, value_or_callback=None, /):
            """
            The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Audience.Builder]()
                context._parent_builder = self
                context._field_name = "audiences"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Audience.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("audiences", value)

        def forward_original_token(self, value: Optional[bool], /) -> Self:
            """
            If set to true, the original token will be kept for the upstream request.
            """
            return self._set("forward_original_token", value)

        @overload
        def from_cookies(self, value_or_callback: List[FromCooky], /) -> "JwtRule.Builder": ...

        @overload
        def from_cookies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FromCooky, FromCooky.Builder]],
                GenericListBuilder[FromCooky, FromCooky.Builder] | List[FromCooky],
            ],
            /,
        ) -> "JwtRule.Builder": ...

        @overload
        def from_cookies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FromCooky.Builder]: ...

        def from_cookies(self, value_or_callback=None, /):
            """
            List of cookie names from which JWT is expected.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FromCooky.Builder]()
                context._parent_builder = self
                context._field_name = "from_cookies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FromCooky.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("from_cookies", value)

        @overload
        def from_headers(self, value_or_callback: List[FromHeader], /) -> "JwtRule.Builder": ...

        @overload
        def from_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FromHeader, FromHeader.Builder]],
                GenericListBuilder[FromHeader, FromHeader.Builder] | List[FromHeader],
            ],
            /,
        ) -> "JwtRule.Builder": ...

        @overload
        def from_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FromHeader.Builder]: ...

        def from_headers(self, value_or_callback=None, /):
            """
            List of header locations from which JWT is expected.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FromHeader.Builder]()
                context._parent_builder = self
                context._field_name = "from_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FromHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("from_headers", value)

        @overload
        def from_params(self, value_or_callback: List[FromParam], /) -> "JwtRule.Builder": ...

        @overload
        def from_params(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FromParam, FromParam.Builder]],
                GenericListBuilder[FromParam, FromParam.Builder] | List[FromParam],
            ],
            /,
        ) -> "JwtRule.Builder": ...

        @overload
        def from_params(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FromParam.Builder]: ...

        def from_params(self, value_or_callback=None, /):
            """
            List of query parameters from which JWT is expected.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FromParam.Builder]()
                context._parent_builder = self
                context._field_name = "from_params"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FromParam.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("from_params", value)

        def issuer(self, value: str, /) -> Self:
            """
            Identifies the issuer that issued the JWT.
            """
            return self._set("issuer", value)

        def jwks(self, value: Optional[str], /) -> Self:
            """
            JSON Web Key Set of public keys to validate signature of the JWT.
            """
            return self._set("jwks", value)

        def jwks_uri(self, value: Optional[str], /) -> Self:
            """
            URL of the provider's public key set to validate signature of the JWT.
            """
            return self._set("jwks_uri", value)

        def jwks_uri_1(self, value: Optional[str], /) -> Self:
            """
            URL of the provider's public key set to validate signature of the JWT.
            """
            return self._set("jwks_uri_1", value)

        @overload
        def output_claim_to_headers(
            self, value_or_callback: List[OutputClaimToHeader], /
        ) -> "JwtRule.Builder": ...

        @overload
        def output_claim_to_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OutputClaimToHeader, OutputClaimToHeader.Builder]],
                GenericListBuilder[OutputClaimToHeader, OutputClaimToHeader.Builder]
                | List[OutputClaimToHeader],
            ],
            /,
        ) -> "JwtRule.Builder": ...

        @overload
        def output_claim_to_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OutputClaimToHeader.Builder]: ...

        def output_claim_to_headers(self, value_or_callback=None, /):
            """
            This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OutputClaimToHeader.Builder]()
                context._parent_builder = self
                context._field_name = "output_claim_to_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutputClaimToHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("output_claim_to_headers", value)

        def output_payload_to_header(self, value: Optional[str], /) -> Self:
            """
            This field specifies the header name to output a successfully verified JWT payload to the backend.
            """
            return self._set("output_payload_to_header", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            The maximum amount of time that the resolver, determined by the PILOT_JWT_ENABLE_REMOTE_JWKS environment variable, will spend waiting for the JWKS to be fetched.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["JwtRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = JwtRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for JwtRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["JwtRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use JwtRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    audiences: Optional[List[Audience]] = None
    """
    The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are allowed to access.
    """
    forward_original_token: Annotated[Optional[bool], Field(alias="forwardOriginalToken")] = None
    """
    If set to true, the original token will be kept for the upstream request.
    """
    from_cookies: Annotated[Optional[List[FromCooky]], Field(alias="fromCookies")] = None
    """
    List of cookie names from which JWT is expected.
    """
    from_headers: Annotated[Optional[List[FromHeader]], Field(alias="fromHeaders")] = None
    """
    List of header locations from which JWT is expected.
    """
    from_params: Annotated[Optional[List[FromParam]], Field(alias="fromParams")] = None
    """
    List of query parameters from which JWT is expected.
    """
    issuer: Annotated[str, Field(min_length=1)]
    """
    Identifies the issuer that issued the JWT.
    """
    jwks: Optional[str] = None
    """
    JSON Web Key Set of public keys to validate signature of the JWT.
    """
    jwks_uri: Annotated[Optional[str], Field(max_length=2048, min_length=1)] = None
    """
    URL of the provider's public key set to validate signature of the JWT.
    """
    jwks_uri_1: Annotated[Optional[str], Field(alias="jwksUri", max_length=2048, min_length=1)] = (
        None
    )
    """
    URL of the provider's public key set to validate signature of the JWT.
    """
    output_claim_to_headers: Annotated[
        Optional[List[OutputClaimToHeader]], Field(alias="outputClaimToHeaders")
    ] = None
    """
    This field specifies a list of operations to copy the claim to HTTP headers on a successfully verified token.
    """
    output_payload_to_header: Annotated[Optional[str], Field(alias="outputPayloadToHeader")] = None
    """
    This field specifies the header name to output a successfully verified JWT payload to the backend.
    """
    timeout: Optional[str] = None
    """
    The maximum amount of time that the resolver, determined by the PILOT_JWT_ENABLE_REMOTE_JWKS environment variable, will spend waiting for the JWKS to be fetched.
    """


class RequestAuthenticationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestAuthenticationSpec"]:
            return RequestAuthenticationSpec

        def build(self) -> "RequestAuthenticationSpec":
            return RequestAuthenticationSpec(**self._attrs)

        @overload
        def jwt_rules(
            self, value_or_callback: List[JwtRule], /
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def jwt_rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[JwtRule, JwtRule.Builder]],
                GenericListBuilder[JwtRule, JwtRule.Builder] | List[JwtRule],
            ],
            /,
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def jwt_rules(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[JwtRule.Builder]: ...

        def jwt_rules(self, value_or_callback=None, /):
            """
            Define the list of JWTs that can be validated at the selected workloads' proxy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[JwtRule.Builder]()
                context._parent_builder = self
                context._field_name = "jwt_rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(JwtRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("jwt_rules", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        @overload
        def target_ref(
            self, value_or_callback: Optional[TargetRef], /
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def target_ref(
            self,
            value_or_callback: Callable[[TargetRef.Builder], TargetRef.Builder | TargetRef],
            /,
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def target_ref(self, value_or_callback: Never = ...) -> "TargetRef.BuilderContext": ...

        def target_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.builder())
                if isinstance(output, TargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_ref", value)

        @overload
        def target_refs(
            self, value_or_callback: List[TargetRef], /
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def target_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetRef, TargetRef.Builder]],
                GenericListBuilder[TargetRef, TargetRef.Builder] | List[TargetRef],
            ],
            /,
        ) -> "RequestAuthenticationSpec.Builder": ...

        @overload
        def target_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetRef.Builder]: ...

        def target_refs(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetRef.Builder]()
                context._parent_builder = self
                context._field_name = "target_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_refs", value)

    class BuilderContext(BuilderContextBase["RequestAuthenticationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestAuthenticationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestAuthenticationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestAuthenticationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestAuthenticationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    jwt_rules: Annotated[Optional[List[JwtRule]], Field(alias="jwtRules", max_length=4096)] = None
    """
    Define the list of JWTs that can be validated at the selected workloads' proxy.
    """
    selector: Optional[Selector] = None
    """
    Optional.
    """
    target_ref: Annotated[Optional[TargetRef], Field(alias="targetRef")] = None
    target_refs: Annotated[Optional[List[TargetRef]], Field(alias="targetRefs", max_length=16)] = (
        None
    )
    """
    Optional.
    """


class RequestAuthenticationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestAuthenticationStatus"]:
            return RequestAuthenticationStatus

        def build(self) -> "RequestAuthenticationStatus":
            return RequestAuthenticationStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "RequestAuthenticationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "RequestAuthenticationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "RequestAuthenticationStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "RequestAuthenticationStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["RequestAuthenticationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestAuthenticationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestAuthenticationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestAuthenticationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestAuthenticationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class AuthorizationPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationPolicy"]:
            return AuthorizationPolicy

        def build(self) -> "AuthorizationPolicy":
            return AuthorizationPolicy(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[AuthorizationPolicySpecModel1], /
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [AuthorizationPolicySpecModel1.Builder],
                AuthorizationPolicySpecModel1.Builder | AuthorizationPolicySpecModel1,
            ],
            /,
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationPolicySpecModel1.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AuthorizationPolicySpecModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationPolicySpecModel1.builder())
                if isinstance(output, AuthorizationPolicySpecModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[AuthorizationPolicyStatus], /
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [AuthorizationPolicyStatus.Builder],
                AuthorizationPolicyStatus.Builder | AuthorizationPolicyStatus,
            ],
            /,
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AuthorizationPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationPolicyStatus.builder())
                if isinstance(output, AuthorizationPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["security.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["AuthorizationPolicy"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "AuthorizationPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["AuthorizationPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[AuthorizationPolicySpecModel1] = None
    status: Optional[AuthorizationPolicyStatus] = None
    api_version: Annotated[Optional[Literal["security.istio.io/v1"]], Field(alias="apiVersion")] = (
        "security.istio.io/v1"
    )
    kind: Optional[Literal["AuthorizationPolicy"]] = "AuthorizationPolicy"
    metadata: Optional[apimachinery.ObjectMeta] = None


class PeerAuthentication(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PeerAuthentication"]:
            return PeerAuthentication

        def build(self) -> "PeerAuthentication":
            return PeerAuthentication(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[PeerAuthenticationSpec], /
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PeerAuthenticationSpec.Builder],
                PeerAuthenticationSpec.Builder | PeerAuthenticationSpec,
            ],
            /,
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "PeerAuthenticationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PeerAuthenticationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PeerAuthenticationSpec.builder())
                if isinstance(output, PeerAuthenticationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PeerAuthenticationStatus], /
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PeerAuthenticationStatus.Builder],
                PeerAuthenticationStatus.Builder | PeerAuthenticationStatus,
            ],
            /,
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PeerAuthenticationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PeerAuthenticationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PeerAuthenticationStatus.builder())
                if isinstance(output, PeerAuthenticationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["security.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PeerAuthentication"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PeerAuthentication.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["PeerAuthentication.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PeerAuthentication.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PeerAuthentication."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PeerAuthentication", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PeerAuthentication.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[PeerAuthenticationSpec] = None
    status: Optional[PeerAuthenticationStatus] = None
    api_version: Annotated[Optional[Literal["security.istio.io/v1"]], Field(alias="apiVersion")] = (
        "security.istio.io/v1"
    )
    kind: Optional[Literal["PeerAuthentication"]] = "PeerAuthentication"
    metadata: Optional[apimachinery.ObjectMeta] = None


class RequestAuthentication(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestAuthentication"]:
            return RequestAuthentication

        def build(self) -> "RequestAuthentication":
            return RequestAuthentication(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[RequestAuthenticationSpec], /
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [RequestAuthenticationSpec.Builder],
                RequestAuthenticationSpec.Builder | RequestAuthenticationSpec,
            ],
            /,
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "RequestAuthenticationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RequestAuthenticationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestAuthenticationSpec.builder())
                if isinstance(output, RequestAuthenticationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[RequestAuthenticationStatus], /
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [RequestAuthenticationStatus.Builder],
                RequestAuthenticationStatus.Builder | RequestAuthenticationStatus,
            ],
            /,
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "RequestAuthenticationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RequestAuthenticationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestAuthenticationStatus.builder())
                if isinstance(output, RequestAuthenticationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["security.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["RequestAuthentication"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "RequestAuthentication.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["RequestAuthentication.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestAuthentication.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestAuthentication."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestAuthentication", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestAuthentication.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[RequestAuthenticationSpec] = None
    status: Optional[RequestAuthenticationStatus] = None
    api_version: Annotated[Optional[Literal["security.istio.io/v1"]], Field(alias="apiVersion")] = (
        "security.istio.io/v1"
    )
    kind: Optional[Literal["RequestAuthentication"]] = "RequestAuthentication"
    metadata: Optional[apimachinery.ObjectMeta] = None
