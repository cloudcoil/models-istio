# Generated by cloudcoil-model-codegen v0.5.4
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from pydantic import Field, RootModel

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Http(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Http"]:
            return Http

        def build(self) -> "Http":
            return Http(**self._attrs)

        def h2_upgrade_policy(
            self, value: Optional[Literal["DEFAULT", "DO_NOT_UPGRADE", "UPGRADE"]], /
        ) -> Self:
            """
            Specify if http1.1 connection should be upgraded to http2 for the associated destination.

            Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
            """
            return self._set("h2_upgrade_policy", value)

        def http1_max_pending_requests(self, value: Optional[int], /) -> Self:
            """
            Maximum number of requests that will be queued while waiting for a ready connection pool connection.
            """
            return self._set("http1_max_pending_requests", value)

        def http2_max_requests(self, value: Optional[int], /) -> Self:
            """
            Maximum number of active requests to a destination.
            """
            return self._set("http2_max_requests", value)

        def idle_timeout(self, value: Optional[str], /) -> Self:
            """
            The idle timeout for upstream connection pool connections.
            """
            return self._set("idle_timeout", value)

        def max_concurrent_streams(self, value: Optional[int], /) -> Self:
            """
            The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
            """
            return self._set("max_concurrent_streams", value)

        def max_requests_per_connection(self, value: Optional[int], /) -> Self:
            """
            Maximum number of requests per connection to a backend.
            """
            return self._set("max_requests_per_connection", value)

        def max_retries(self, value: Optional[int], /) -> Self:
            """
            Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
            """
            return self._set("max_retries", value)

        def use_client_protocol(self, value: Optional[bool], /) -> Self:
            """
            If set to true, client protocol will be preserved while initiating connection to backend.
            """
            return self._set("use_client_protocol", value)

    class BuilderContext(BuilderContextBase["Http.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Http.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Http."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Http", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Http.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    h2_upgrade_policy: Annotated[
        Optional[Literal["DEFAULT", "DO_NOT_UPGRADE", "UPGRADE"]],
        Field(alias="h2UpgradePolicy"),
    ] = None
    """
    Specify if http1.1 connection should be upgraded to http2 for the associated destination.

    Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
    """
    http1_max_pending_requests: Annotated[Optional[int], Field(alias="http1MaxPendingRequests")] = (
        None
    )
    """
    Maximum number of requests that will be queued while waiting for a ready connection pool connection.
    """
    http2_max_requests: Annotated[Optional[int], Field(alias="http2MaxRequests")] = None
    """
    Maximum number of active requests to a destination.
    """
    idle_timeout: Annotated[Optional[str], Field(alias="idleTimeout")] = None
    """
    The idle timeout for upstream connection pool connections.
    """
    max_concurrent_streams: Annotated[Optional[int], Field(alias="maxConcurrentStreams")] = None
    """
    The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
    """
    max_requests_per_connection: Annotated[
        Optional[int], Field(alias="maxRequestsPerConnection")
    ] = None
    """
    Maximum number of requests per connection to a backend.
    """
    max_retries: Annotated[Optional[int], Field(alias="maxRetries")] = None
    """
    Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
    """
    use_client_protocol: Annotated[Optional[bool], Field(alias="useClientProtocol")] = None
    """
    If set to true, client protocol will be preserved while initiating connection to backend.
    """


class TcpKeepalive(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpKeepalive"]:
            return TcpKeepalive

        def build(self) -> "TcpKeepalive":
            return TcpKeepalive(**self._attrs)

        def interval(self, value: Optional[str], /) -> Self:
            """
            The time duration between keep-alive probes.
            """
            return self._set("interval", value)

        def probes(self, value: Optional[int], /) -> Self:
            """
            Maximum number of keepalive probes to send without response before deciding the connection is dead.
            """
            return self._set("probes", value)

        def time(self, value: Optional[str], /) -> Self:
            """
            The time duration a connection needs to be idle before keep-alive probes start being sent.
            """
            return self._set("time", value)

    class BuilderContext(BuilderContextBase["TcpKeepalive.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpKeepalive.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpKeepalive."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpKeepalive", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpKeepalive.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    interval: Optional[str] = None
    """
    The time duration between keep-alive probes.
    """
    probes: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    Maximum number of keepalive probes to send without response before deciding the connection is dead.
    """
    time: Optional[str] = None
    """
    The time duration a connection needs to be idle before keep-alive probes start being sent.
    """


class Tcp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tcp"]:
            return Tcp

        def build(self) -> "Tcp":
            return Tcp(**self._attrs)

        def connect_timeout(self, value: Optional[str], /) -> Self:
            """
            TCP connection timeout.
            """
            return self._set("connect_timeout", value)

        def idle_timeout(self, value: Optional[str], /) -> Self:
            """
            The idle timeout for TCP connections.
            """
            return self._set("idle_timeout", value)

        def max_connection_duration(self, value: Optional[str], /) -> Self:
            """
            The maximum duration of a connection.
            """
            return self._set("max_connection_duration", value)

        def max_connections(self, value: Optional[int], /) -> Self:
            """
            Maximum number of HTTP1 /TCP connections to a destination host.
            """
            return self._set("max_connections", value)

        @overload
        def tcp_keepalive(self, value_or_callback: Optional[TcpKeepalive], /) -> "Tcp.Builder": ...

        @overload
        def tcp_keepalive(
            self,
            value_or_callback: Callable[
                [TcpKeepalive.Builder], TcpKeepalive.Builder | TcpKeepalive
            ],
            /,
        ) -> "Tcp.Builder": ...

        @overload
        def tcp_keepalive(
            self, value_or_callback: Never = ...
        ) -> "TcpKeepalive.BuilderContext": ...

        def tcp_keepalive(self, value_or_callback=None, /):
            """
            If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            """
            if self._in_context and value_or_callback is None:
                context = TcpKeepalive.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_keepalive"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpKeepalive.builder())
                if isinstance(output, TcpKeepalive.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_keepalive", value)

    class BuilderContext(BuilderContextBase["Tcp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tcp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tcp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tcp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tcp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    connect_timeout: Annotated[Optional[str], Field(alias="connectTimeout")] = None
    """
    TCP connection timeout.
    """
    idle_timeout: Annotated[Optional[str], Field(alias="idleTimeout")] = None
    """
    The idle timeout for TCP connections.
    """
    max_connection_duration: Annotated[Optional[str], Field(alias="maxConnectionDuration")] = None
    """
    The maximum duration of a connection.
    """
    max_connections: Annotated[Optional[int], Field(alias="maxConnections")] = None
    """
    Maximum number of HTTP1 /TCP connections to a destination host.
    """
    tcp_keepalive: Annotated[Optional[TcpKeepalive], Field(alias="tcpKeepalive")] = None
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """


class ConnectionPool(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionPool"]:
            return ConnectionPool

        def build(self) -> "ConnectionPool":
            return ConnectionPool(**self._attrs)

        @overload
        def http(self, value_or_callback: Optional[Http], /) -> "ConnectionPool.Builder": ...

        @overload
        def http(
            self, value_or_callback: Callable[[Http.Builder], Http.Builder | Http], /
        ) -> "ConnectionPool.Builder": ...

        @overload
        def http(self, value_or_callback: Never = ...) -> "Http.BuilderContext": ...

        def http(self, value_or_callback=None, /):
            """
            HTTP connection pool settings.
            """
            if self._in_context and value_or_callback is None:
                context = Http.BuilderContext()
                context._parent_builder = self
                context._field_name = "http"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Http.builder())
                if isinstance(output, Http.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http", value)

        @overload
        def tcp(self, value_or_callback: Optional[Tcp], /) -> "ConnectionPool.Builder": ...

        @overload
        def tcp(
            self, value_or_callback: Callable[[Tcp.Builder], Tcp.Builder | Tcp], /
        ) -> "ConnectionPool.Builder": ...

        @overload
        def tcp(self, value_or_callback: Never = ...) -> "Tcp.BuilderContext": ...

        def tcp(self, value_or_callback=None, /):
            """
            Settings common to both HTTP and TCP upstream connections.
            """
            if self._in_context and value_or_callback is None:
                context = Tcp.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tcp.builder())
                if isinstance(output, Tcp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp", value)

    class BuilderContext(BuilderContextBase["ConnectionPool.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionPool.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionPool."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionPool", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionPool.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http: Optional[Http] = None
    """
    HTTP connection pool settings.
    """
    tcp: Optional[Tcp] = None
    """
    Settings common to both HTTP and TCP upstream connections.
    """


class HttpCookie(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpCookie"]:
            return HttpCookie

        def build(self) -> "HttpCookie":
            return HttpCookie(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the cookie.
            """
            return self._set("name", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to set for the cookie.
            """
            return self._set("path", value)

        def ttl(self, value: Optional[str], /) -> Self:
            """
            Lifetime of the cookie.
            """
            return self._set("ttl", value)

    class BuilderContext(BuilderContextBase["HttpCookie.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpCookie.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpCookie."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpCookie", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpCookie.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the cookie.
    """
    path: Optional[str] = None
    """
    Path to set for the cookie.
    """
    ttl: Optional[str] = None
    """
    Lifetime of the cookie.
    """


class Maglev(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Maglev"]:
            return Maglev

        def build(self) -> "Maglev":
            return Maglev(**self._attrs)

        def table_size(self, value: Optional[int], /) -> Self:
            """
            The table size for Maglev hashing.
            """
            return self._set("table_size", value)

    class BuilderContext(BuilderContextBase["Maglev.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Maglev.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Maglev."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Maglev", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Maglev.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    table_size: Annotated[Optional[int], Field(alias="tableSize", ge=0)] = None
    """
    The table size for Maglev hashing.
    """


class RingHash(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RingHash"]:
            return RingHash

        def build(self) -> "RingHash":
            return RingHash(**self._attrs)

        def minimum_ring_size(self, value: Optional[int], /) -> Self:
            """
            The minimum number of virtual nodes to use for the hash ring.
            """
            return self._set("minimum_ring_size", value)

    class BuilderContext(BuilderContextBase["RingHash.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RingHash.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RingHash."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RingHash", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RingHash.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    minimum_ring_size: Annotated[Optional[int], Field(alias="minimumRingSize", ge=0)] = None
    """
    The minimum number of virtual nodes to use for the hash ring.
    """


class ConsistentHash(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConsistentHash"]:
            return ConsistentHash

        def build(self) -> "ConsistentHash":
            return ConsistentHash(**self._attrs)

        @overload
        def http_cookie(
            self, value_or_callback: Optional[HttpCookie], /
        ) -> "ConsistentHash.Builder": ...

        @overload
        def http_cookie(
            self,
            value_or_callback: Callable[[HttpCookie.Builder], HttpCookie.Builder | HttpCookie],
            /,
        ) -> "ConsistentHash.Builder": ...

        @overload
        def http_cookie(self, value_or_callback: Never = ...) -> "HttpCookie.BuilderContext": ...

        def http_cookie(self, value_or_callback=None, /):
            """
            Hash based on HTTP cookie.
            """
            if self._in_context and value_or_callback is None:
                context = HttpCookie.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_cookie"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpCookie.builder())
                if isinstance(output, HttpCookie.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_cookie", value)

        def http_header_name(self, value: Optional[str], /) -> Self:
            """
            Hash based on a specific HTTP header.
            """
            return self._set("http_header_name", value)

        def http_query_parameter_name(self, value: Optional[str], /) -> Self:
            """
            Hash based on a specific HTTP query parameter.
            """
            return self._set("http_query_parameter_name", value)

        @overload
        def maglev(self, value_or_callback: Optional[Maglev], /) -> "ConsistentHash.Builder": ...

        @overload
        def maglev(
            self,
            value_or_callback: Callable[[Maglev.Builder], Maglev.Builder | Maglev],
            /,
        ) -> "ConsistentHash.Builder": ...

        @overload
        def maglev(self, value_or_callback: Never = ...) -> "Maglev.BuilderContext": ...

        def maglev(self, value_or_callback=None, /):
            """
            The Maglev load balancer implements consistent hashing to backend hosts.
            """
            if self._in_context and value_or_callback is None:
                context = Maglev.BuilderContext()
                context._parent_builder = self
                context._field_name = "maglev"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Maglev.builder())
                if isinstance(output, Maglev.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("maglev", value)

        def minimum_ring_size(self, value: Optional[int], /) -> Self:
            """
            Deprecated.
            """
            return self._set("minimum_ring_size", value)

        @overload
        def ring_hash(
            self, value_or_callback: Optional[RingHash], /
        ) -> "ConsistentHash.Builder": ...

        @overload
        def ring_hash(
            self,
            value_or_callback: Callable[[RingHash.Builder], RingHash.Builder | RingHash],
            /,
        ) -> "ConsistentHash.Builder": ...

        @overload
        def ring_hash(self, value_or_callback: Never = ...) -> "RingHash.BuilderContext": ...

        def ring_hash(self, value_or_callback=None, /):
            """
            The ring/modulo hash load balancer implements consistent hashing to backend hosts.
            """
            if self._in_context and value_or_callback is None:
                context = RingHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "ring_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RingHash.builder())
                if isinstance(output, RingHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ring_hash", value)

        def use_source_ip(self, value: Optional[bool], /) -> Self:
            """
            Hash based on the source IP address.
            """
            return self._set("use_source_ip", value)

    class BuilderContext(BuilderContextBase["ConsistentHash.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConsistentHash.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConsistentHash."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConsistentHash", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConsistentHash.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_cookie: Annotated[Optional[HttpCookie], Field(alias="httpCookie")] = None
    """
    Hash based on HTTP cookie.
    """
    http_header_name: Annotated[Optional[str], Field(alias="httpHeaderName")] = None
    """
    Hash based on a specific HTTP header.
    """
    http_query_parameter_name: Annotated[Optional[str], Field(alias="httpQueryParameterName")] = (
        None
    )
    """
    Hash based on a specific HTTP query parameter.
    """
    maglev: Optional[Maglev] = None
    """
    The Maglev load balancer implements consistent hashing to backend hosts.
    """
    minimum_ring_size: Annotated[Optional[int], Field(alias="minimumRingSize", ge=0)] = None
    """
    Deprecated.
    """
    ring_hash: Annotated[Optional[RingHash], Field(alias="ringHash")] = None
    """
    The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    """
    use_source_ip: Annotated[Optional[bool], Field(alias="useSourceIp")] = None
    """
    Hash based on the source IP address.
    """


class Distribute(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Distribute"]:
            return Distribute

        def build(self) -> "Distribute":
            return Distribute(**self._attrs)

        def from_(self, value: Optional[str], /) -> Self:
            """
            Originating locality, '/' separated, e.g.
            """
            return self._set("from_", value)

        def to(self, value: Optional[Dict[str, int]], /) -> Self:
            """
            Map of upstream localities to traffic distribution weights.
            """
            return self._set("to", value)

    class BuilderContext(BuilderContextBase["Distribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Distribute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Distribute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Distribute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Distribute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_: Annotated[Optional[str], Field(alias="from")] = None
    """
    Originating locality, '/' separated, e.g.
    """
    to: Optional[Dict[str, int]] = None
    """
    Map of upstream localities to traffic distribution weights.
    """


class Failover(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Failover"]:
            return Failover

        def build(self) -> "Failover":
            return Failover(**self._attrs)

        def from_(self, value: Optional[str], /) -> Self:
            """
            Originating region.
            """
            return self._set("from_", value)

        def to(self, value: Optional[str], /) -> Self:
            """
            Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
            """
            return self._set("to", value)

    class BuilderContext(BuilderContextBase["Failover.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Failover.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Failover."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Failover", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Failover.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_: Annotated[Optional[str], Field(alias="from")] = None
    """
    Originating region.
    """
    to: Optional[str] = None
    """
    Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
    """


class LocalityLbSetting(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LocalityLbSetting"]:
            return LocalityLbSetting

        def build(self) -> "LocalityLbSetting":
            return LocalityLbSetting(**self._attrs)

        @overload
        def distribute(
            self, value_or_callback: List[Distribute], /
        ) -> "LocalityLbSetting.Builder": ...

        @overload
        def distribute(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Distribute, Distribute.Builder]],
                GenericListBuilder[Distribute, Distribute.Builder] | List[Distribute],
            ],
            /,
        ) -> "LocalityLbSetting.Builder": ...

        @overload
        def distribute(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Distribute.Builder]: ...

        def distribute(self, value_or_callback=None, /):
            """
            Optional: only one of distribute, failover or failoverPriority can be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Distribute.Builder]()
                context._parent_builder = self
                context._field_name = "distribute"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Distribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("distribute", value)

        def enabled(self, value: Optional[bool], /) -> Self:
            """
            enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
            """
            return self._set("enabled", value)

        @overload
        def failover(self, value_or_callback: List[Failover], /) -> "LocalityLbSetting.Builder": ...

        @overload
        def failover(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Failover, Failover.Builder]],
                GenericListBuilder[Failover, Failover.Builder] | List[Failover],
            ],
            /,
        ) -> "LocalityLbSetting.Builder": ...

        @overload
        def failover(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Failover.Builder]: ...

        def failover(self, value_or_callback=None, /):
            """
            Optional: only one of distribute, failover or failoverPriority can be set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Failover.Builder]()
                context._parent_builder = self
                context._field_name = "failover"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Failover.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("failover", value)

        def failover_priority(self, value: Optional[List[str]], /) -> Self:
            """
            failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
            """
            return self._set("failover_priority", value)

    class BuilderContext(BuilderContextBase["LocalityLbSetting.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LocalityLbSetting.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LocalityLbSetting."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LocalityLbSetting", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LocalityLbSetting.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    distribute: Optional[List[Distribute]] = None
    """
    Optional: only one of distribute, failover or failoverPriority can be set.
    """
    enabled: Optional[bool] = None
    """
    enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    """
    failover: Optional[List[Failover]] = None
    """
    Optional: only one of distribute, failover or failoverPriority can be set.
    """
    failover_priority: Annotated[Optional[List[str]], Field(alias="failoverPriority")] = None
    """
    failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    """


class Warmup(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Warmup"]:
            return Warmup

        def build(self) -> "Warmup":
            return Warmup(**self._attrs)

        def aggression(self, value: Optional[float], /) -> Self:
            """
            This parameter controls the speed of traffic increase over the warmup duration.
            """
            return self._set("aggression", value)

        def duration(self, value: str, /) -> Self:
            return self._set("duration", value)

        def minimum_percent(self, value: Optional[float], /) -> Self:
            return self._set("minimum_percent", value)

    class BuilderContext(BuilderContextBase["Warmup.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Warmup.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Warmup."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Warmup", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Warmup.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aggression: Annotated[Optional[float], Field(ge=1.0)] = None
    """
    This parameter controls the speed of traffic increase over the warmup duration.
    """
    duration: str
    minimum_percent: Annotated[Optional[float], Field(alias="minimumPercent", ge=0.0, le=100.0)] = (
        None
    )


class LoadBalancer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancer"]:
            return LoadBalancer

        def build(self) -> "LoadBalancer":
            return LoadBalancer(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancer.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancer.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancer.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancer.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(self, value_or_callback: Optional[Warmup], /) -> "LoadBalancer.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancer.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel"]:
            return LoadBalancerModel

        def build(self) -> "LoadBalancerModel":
            return LoadBalancerModel(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Literal[
                "UNSPECIFIED",
                "LEAST_CONN",
                "RANDOM",
                "PASSTHROUGH",
                "ROUND_ROBIN",
                "LEAST_REQUEST",
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(self, value_or_callback: Optional[Warmup], /) -> "LoadBalancerModel.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Literal[
        "UNSPECIFIED",
        "LEAST_CONN",
        "RANDOM",
        "PASSTHROUGH",
        "ROUND_ROBIN",
        "LEAST_REQUEST",
    ]
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel1"]:
            return LoadBalancerModel1

        def build(self) -> "LoadBalancerModel1":
            return LoadBalancerModel1(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: ConsistentHash, /
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel1.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[ConsistentHash, Field(alias="consistentHash")]
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class OutlierDetection(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OutlierDetection"]:
            return OutlierDetection

        def build(self) -> "OutlierDetection":
            return OutlierDetection(**self._attrs)

        def base_ejection_time(self, value: Optional[str], /) -> Self:
            """
            Minimum ejection duration.
            """
            return self._set("base_ejection_time", value)

        def consecutive5xx_errors(self, value: Optional[int], /) -> Self:
            """
            Number of 5xx errors before a host is ejected from the connection pool.
            """
            return self._set("consecutive5xx_errors", value)

        def consecutive_errors(self, value: Optional[int], /) -> Self:
            return self._set("consecutive_errors", value)

        def consecutive_gateway_errors(self, value: Optional[int], /) -> Self:
            """
            Number of gateway errors before a host is ejected from the connection pool.
            """
            return self._set("consecutive_gateway_errors", value)

        def consecutive_local_origin_failures(self, value: Optional[int], /) -> Self:
            """
            The number of consecutive locally originated failures before ejection occurs.
            """
            return self._set("consecutive_local_origin_failures", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Time interval between ejection sweep analysis.
            """
            return self._set("interval", value)

        def max_ejection_percent(self, value: Optional[int], /) -> Self:
            """
            Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
            """
            return self._set("max_ejection_percent", value)

        def min_health_percent(self, value: Optional[int], /) -> Self:
            """
            Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
            """
            return self._set("min_health_percent", value)

        def split_external_local_origin_errors(self, value: Optional[bool], /) -> Self:
            """
            Determines whether to distinguish local origin failures from external errors.
            """
            return self._set("split_external_local_origin_errors", value)

    class BuilderContext(BuilderContextBase["OutlierDetection.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OutlierDetection.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OutlierDetection."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OutlierDetection", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OutlierDetection.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    base_ejection_time: Annotated[Optional[str], Field(alias="baseEjectionTime")] = None
    """
    Minimum ejection duration.
    """
    consecutive5xx_errors: Annotated[
        Optional[int], Field(alias="consecutive5xxErrors", ge=0, le=4294967295)
    ] = None
    """
    Number of 5xx errors before a host is ejected from the connection pool.
    """
    consecutive_errors: Annotated[Optional[int], Field(alias="consecutiveErrors")] = None
    consecutive_gateway_errors: Annotated[
        Optional[int], Field(alias="consecutiveGatewayErrors", ge=0, le=4294967295)
    ] = None
    """
    Number of gateway errors before a host is ejected from the connection pool.
    """
    consecutive_local_origin_failures: Annotated[
        Optional[int],
        Field(alias="consecutiveLocalOriginFailures", ge=0, le=4294967295),
    ] = None
    """
    The number of consecutive locally originated failures before ejection occurs.
    """
    interval: Optional[str] = None
    """
    Time interval between ejection sweep analysis.
    """
    max_ejection_percent: Annotated[Optional[int], Field(alias="maxEjectionPercent")] = None
    """
    Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
    """
    min_health_percent: Annotated[Optional[int], Field(alias="minHealthPercent")] = None
    """
    Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.
    """
    split_external_local_origin_errors: Annotated[
        Optional[bool], Field(alias="splitExternalLocalOriginErrors")
    ] = None
    """
    Determines whether to distinguish local origin failures from external errors.
    """


class LoadBalancerModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel2"]:
            return LoadBalancerModel2

        def build(self) -> "LoadBalancerModel2":
            return LoadBalancerModel2(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel2.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel3"]:
            return LoadBalancerModel3

        def build(self) -> "LoadBalancerModel3":
            return LoadBalancerModel3(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Literal[
                "UNSPECIFIED",
                "LEAST_CONN",
                "RANDOM",
                "PASSTHROUGH",
                "ROUND_ROBIN",
                "LEAST_REQUEST",
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel3.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Literal[
        "UNSPECIFIED",
        "LEAST_CONN",
        "RANDOM",
        "PASSTHROUGH",
        "ROUND_ROBIN",
        "LEAST_REQUEST",
    ]
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel4"]:
            return LoadBalancerModel4

        def build(self) -> "LoadBalancerModel4":
            return LoadBalancerModel4(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: ConsistentHash, /
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel4.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[ConsistentHash, Field(alias="consistentHash")]
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class Port(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Port"]:
            return Port

        def build(self) -> "Port":
            return Port(**self._attrs)

        def number(self, value: Optional[int], /) -> Self:
            return self._set("number", value)

    class BuilderContext(BuilderContextBase["Port.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Port.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Port."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Port", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Port.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    number: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None


class Tls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tls"]:
            return Tls

        def build(self) -> "Tls":
            return Tls(**self._attrs)

        def ca_certificates(self, value: Optional[str], /) -> Self:
            """
            OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
            """
            return self._set("ca_certificates", value)

        def ca_crl(self, value: Optional[str], /) -> Self:
            """
            OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
            """
            return self._set("ca_crl", value)

        def client_certificate(self, value: Optional[str], /) -> Self:
            """
            REQUIRED if mode is `MUTUAL`.
            """
            return self._set("client_certificate", value)

        def credential_name(self, value: Optional[str], /) -> Self:
            """
            The name of the secret that holds the TLS certs for the client including the CA certificates.
            """
            return self._set("credential_name", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
            """
            return self._set("insecure_skip_verify", value)

        def mode(
            self,
            value: Optional[Literal["DISABLE", "SIMPLE", "MUTUAL", "ISTIO_MUTUAL"]],
            /,
        ) -> Self:
            """
            Indicates whether connections to this port should be secured using TLS.

            Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
            """
            return self._set("mode", value)

        def private_key(self, value: Optional[str], /) -> Self:
            """
            REQUIRED if mode is `MUTUAL`.
            """
            return self._set("private_key", value)

        def sni(self, value: Optional[str], /) -> Self:
            """
            SNI string to present to the server during TLS handshake.
            """
            return self._set("sni", value)

        def subject_alt_names(self, value: Optional[List[str]], /) -> Self:
            """
            A list of alternate names to verify the subject identity in the certificate.
            """
            return self._set("subject_alt_names", value)

    class BuilderContext(BuilderContextBase["Tls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_certificates: Annotated[Optional[str], Field(alias="caCertificates")] = None
    """
    OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
    """
    ca_crl: Annotated[Optional[str], Field(alias="caCrl")] = None
    """
    OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
    """
    client_certificate: Annotated[Optional[str], Field(alias="clientCertificate")] = None
    """
    REQUIRED if mode is `MUTUAL`.
    """
    credential_name: Annotated[Optional[str], Field(alias="credentialName")] = None
    """
    The name of the secret that holds the TLS certs for the client including the CA certificates.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
    """
    mode: Optional[Literal["DISABLE", "SIMPLE", "MUTUAL", "ISTIO_MUTUAL"]] = None
    """
    Indicates whether connections to this port should be secured using TLS.

    Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
    """
    private_key: Annotated[Optional[str], Field(alias="privateKey")] = None
    """
    REQUIRED if mode is `MUTUAL`.
    """
    sni: Optional[str] = None
    """
    SNI string to present to the server during TLS handshake.
    """
    subject_alt_names: Annotated[Optional[List[str]], Field(alias="subjectAltNames")] = None
    """
    A list of alternate names to verify the subject identity in the certificate.
    """


class PortLevelSetting(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortLevelSetting"]:
            return PortLevelSetting

        def build(self) -> "PortLevelSetting":
            return PortLevelSetting(**self._attrs)

        @overload
        def connection_pool(
            self, value_or_callback: Optional[ConnectionPool], /
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def connection_pool(
            self,
            value_or_callback: Callable[
                [ConnectionPool.Builder], ConnectionPool.Builder | ConnectionPool
            ],
            /,
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def connection_pool(
            self, value_or_callback: Never = ...
        ) -> "ConnectionPool.BuilderContext": ...

        def connection_pool(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConnectionPool.BuilderContext()
                context._parent_builder = self
                context._field_name = "connection_pool"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionPool.builder())
                if isinstance(output, ConnectionPool.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("connection_pool", value)

        def load_balancer(
            self,
            value: Optional[Union[LoadBalancerModel2, LoadBalancerModel3, LoadBalancerModel4]],
            /,
        ) -> Self:
            """
            Settings controlling the load balancer algorithms.
            """
            return self._set("load_balancer", value)

        @overload
        def outlier_detection(
            self, value_or_callback: Optional[OutlierDetection], /
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def outlier_detection(
            self,
            value_or_callback: Callable[
                [OutlierDetection.Builder], OutlierDetection.Builder | OutlierDetection
            ],
            /,
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def outlier_detection(
            self, value_or_callback: Never = ...
        ) -> "OutlierDetection.BuilderContext": ...

        def outlier_detection(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = OutlierDetection.BuilderContext()
                context._parent_builder = self
                context._field_name = "outlier_detection"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutlierDetection.builder())
                if isinstance(output, OutlierDetection.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("outlier_detection", value)

        @overload
        def port(self, value_or_callback: Optional[Port], /) -> "PortLevelSetting.Builder": ...

        @overload
        def port(
            self, value_or_callback: Callable[[Port.Builder], Port.Builder | Port], /
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "Port.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            Specifies the number of a port on the destination service on which this policy is being applied.
            """
            if self._in_context and value_or_callback is None:
                context = Port.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.builder())
                if isinstance(output, Port.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "PortLevelSetting.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "PortLevelSetting.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS related settings for connections to the upstream service.
            """
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["PortLevelSetting.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortLevelSetting.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortLevelSetting."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortLevelSetting", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortLevelSetting.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    connection_pool: Annotated[Optional[ConnectionPool], Field(alias="connectionPool")] = None
    load_balancer: Annotated[
        Optional[Union[LoadBalancerModel2, LoadBalancerModel3, LoadBalancerModel4]],
        Field(alias="loadBalancer"),
    ] = None
    """
    Settings controlling the load balancer algorithms.
    """
    outlier_detection: Annotated[Optional[OutlierDetection], Field(alias="outlierDetection")] = None
    port: Optional[Port] = None
    """
    Specifies the number of a port on the destination service on which this policy is being applied.
    """
    tls: Optional[Tls] = None
    """
    TLS related settings for connections to the upstream service.
    """


class ProxyProtocol(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxyProtocol"]:
            return ProxyProtocol

        def build(self) -> "ProxyProtocol":
            return ProxyProtocol(**self._attrs)

        def version(self, value: Optional[Literal["V1", "V2"]], /) -> Self:
            """
            The PROXY protocol version to use.

            Valid Options: V1, V2
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["ProxyProtocol.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxyProtocol.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxyProtocol."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxyProtocol", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxyProtocol.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    version: Optional[Literal["V1", "V2"]] = None
    """
    The PROXY protocol version to use.

    Valid Options: V1, V2
    """


class Tunnel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tunnel"]:
            return Tunnel

        def build(self) -> "Tunnel":
            return Tunnel(**self._attrs)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            Specifies which protocol to use for tunneling the downstream connection.
            """
            return self._set("protocol", value)

        def target_host(self, value: str, /) -> Self:
            """
            Specifies a host to which the downstream connection is tunneled.
            """
            return self._set("target_host", value)

        def target_port(self, value: int, /) -> Self:
            """
            Specifies a port to which the downstream connection is tunneled.
            """
            return self._set("target_port", value)

    class BuilderContext(BuilderContextBase["Tunnel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tunnel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tunnel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tunnel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tunnel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    protocol: Optional[str] = None
    """
    Specifies which protocol to use for tunneling the downstream connection.
    """
    target_host: Annotated[str, Field(alias="targetHost")]
    """
    Specifies a host to which the downstream connection is tunneled.
    """
    target_port: Annotated[int, Field(alias="targetPort", ge=0, le=4294967295)]
    """
    Specifies a port to which the downstream connection is tunneled.
    """


class TrafficPolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TrafficPolicy"]:
            return TrafficPolicy

        def build(self) -> "TrafficPolicy":
            return TrafficPolicy(**self._attrs)

        @overload
        def connection_pool(
            self, value_or_callback: Optional[ConnectionPool], /
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def connection_pool(
            self,
            value_or_callback: Callable[
                [ConnectionPool.Builder], ConnectionPool.Builder | ConnectionPool
            ],
            /,
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def connection_pool(
            self, value_or_callback: Never = ...
        ) -> "ConnectionPool.BuilderContext": ...

        def connection_pool(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConnectionPool.BuilderContext()
                context._parent_builder = self
                context._field_name = "connection_pool"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionPool.builder())
                if isinstance(output, ConnectionPool.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("connection_pool", value)

        def load_balancer(
            self,
            value: Optional[Union[LoadBalancer, LoadBalancerModel, LoadBalancerModel1]],
            /,
        ) -> Self:
            """
            Settings controlling the load balancer algorithms.
            """
            return self._set("load_balancer", value)

        @overload
        def outlier_detection(
            self, value_or_callback: Optional[OutlierDetection], /
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def outlier_detection(
            self,
            value_or_callback: Callable[
                [OutlierDetection.Builder], OutlierDetection.Builder | OutlierDetection
            ],
            /,
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def outlier_detection(
            self, value_or_callback: Never = ...
        ) -> "OutlierDetection.BuilderContext": ...

        def outlier_detection(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = OutlierDetection.BuilderContext()
                context._parent_builder = self
                context._field_name = "outlier_detection"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutlierDetection.builder())
                if isinstance(output, OutlierDetection.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("outlier_detection", value)

        @overload
        def port_level_settings(
            self, value_or_callback: List[PortLevelSetting], /
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def port_level_settings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PortLevelSetting, PortLevelSetting.Builder]],
                GenericListBuilder[PortLevelSetting, PortLevelSetting.Builder]
                | List[PortLevelSetting],
            ],
            /,
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def port_level_settings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PortLevelSetting.Builder]: ...

        def port_level_settings(self, value_or_callback=None, /):
            """
            Traffic policies specific to individual ports.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PortLevelSetting.Builder]()
                context._parent_builder = self
                context._field_name = "port_level_settings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortLevelSetting.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("port_level_settings", value)

        @overload
        def proxy_protocol(
            self, value_or_callback: Optional[ProxyProtocol], /
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def proxy_protocol(
            self,
            value_or_callback: Callable[
                [ProxyProtocol.Builder], ProxyProtocol.Builder | ProxyProtocol
            ],
            /,
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def proxy_protocol(
            self, value_or_callback: Never = ...
        ) -> "ProxyProtocol.BuilderContext": ...

        def proxy_protocol(self, value_or_callback=None, /):
            """
            The upstream PROXY protocol settings.
            """
            if self._in_context and value_or_callback is None:
                context = ProxyProtocol.BuilderContext()
                context._parent_builder = self
                context._field_name = "proxy_protocol"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProxyProtocol.builder())
                if isinstance(output, ProxyProtocol.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("proxy_protocol", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "TrafficPolicy.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS related settings for connections to the upstream service.
            """
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        @overload
        def tunnel(self, value_or_callback: Optional[Tunnel], /) -> "TrafficPolicy.Builder": ...

        @overload
        def tunnel(
            self,
            value_or_callback: Callable[[Tunnel.Builder], Tunnel.Builder | Tunnel],
            /,
        ) -> "TrafficPolicy.Builder": ...

        @overload
        def tunnel(self, value_or_callback: Never = ...) -> "Tunnel.BuilderContext": ...

        def tunnel(self, value_or_callback=None, /):
            """
            Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
            """
            if self._in_context and value_or_callback is None:
                context = Tunnel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tunnel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tunnel.builder())
                if isinstance(output, Tunnel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tunnel", value)

    class BuilderContext(BuilderContextBase["TrafficPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TrafficPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TrafficPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TrafficPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TrafficPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    connection_pool: Annotated[Optional[ConnectionPool], Field(alias="connectionPool")] = None
    load_balancer: Annotated[
        Optional[Union[LoadBalancer, LoadBalancerModel, LoadBalancerModel1]],
        Field(alias="loadBalancer"),
    ] = None
    """
    Settings controlling the load balancer algorithms.
    """
    outlier_detection: Annotated[Optional[OutlierDetection], Field(alias="outlierDetection")] = None
    port_level_settings: Annotated[
        Optional[List[PortLevelSetting]],
        Field(alias="portLevelSettings", max_length=4096),
    ] = None
    """
    Traffic policies specific to individual ports.
    """
    proxy_protocol: Annotated[Optional[ProxyProtocol], Field(alias="proxyProtocol")] = None
    """
    The upstream PROXY protocol settings.
    """
    tls: Optional[Tls] = None
    """
    TLS related settings for connections to the upstream service.
    """
    tunnel: Optional[Tunnel] = None
    """
    Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
    """


class Subset(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subset"]:
            return Subset

        def build(self) -> "Subset":
            return Subset(**self._attrs)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels apply a filter over the endpoints of a service in the service registry.
            """
            return self._set("labels", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the subset.
            """
            return self._set("name", value)

        @overload
        def traffic_policy(
            self, value_or_callback: Optional[TrafficPolicy], /
        ) -> "Subset.Builder": ...

        @overload
        def traffic_policy(
            self,
            value_or_callback: Callable[
                [TrafficPolicy.Builder], TrafficPolicy.Builder | TrafficPolicy
            ],
            /,
        ) -> "Subset.Builder": ...

        @overload
        def traffic_policy(
            self, value_or_callback: Never = ...
        ) -> "TrafficPolicy.BuilderContext": ...

        def traffic_policy(self, value_or_callback=None, /):
            """
            Traffic policies that apply to this subset.
            """
            if self._in_context and value_or_callback is None:
                context = TrafficPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "traffic_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TrafficPolicy.builder())
                if isinstance(output, TrafficPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic_policy", value)

    class BuilderContext(BuilderContextBase["Subset.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subset.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subset."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subset", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subset.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    labels: Optional[Dict[str, str]] = None
    """
    Labels apply a filter over the endpoints of a service in the service registry.
    """
    name: str
    """
    Name of the subset.
    """
    traffic_policy: Annotated[Optional[TrafficPolicy], Field(alias="trafficPolicy")] = None
    """
    Traffic policies that apply to this subset.
    """


class LoadBalancerModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel5"]:
            return LoadBalancerModel5

        def build(self) -> "LoadBalancerModel5":
            return LoadBalancerModel5(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel5.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel6"]:
            return LoadBalancerModel6

        def build(self) -> "LoadBalancerModel6":
            return LoadBalancerModel6(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Literal[
                "UNSPECIFIED",
                "LEAST_CONN",
                "RANDOM",
                "PASSTHROUGH",
                "ROUND_ROBIN",
                "LEAST_REQUEST",
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel6.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Literal[
        "UNSPECIFIED",
        "LEAST_CONN",
        "RANDOM",
        "PASSTHROUGH",
        "ROUND_ROBIN",
        "LEAST_REQUEST",
    ]
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel7"]:
            return LoadBalancerModel7

        def build(self) -> "LoadBalancerModel7":
            return LoadBalancerModel7(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: ConsistentHash, /
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel7.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[ConsistentHash, Field(alias="consistentHash")]
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel8"]:
            return LoadBalancerModel8

        def build(self) -> "LoadBalancerModel8":
            return LoadBalancerModel8(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel8.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel9(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel9"]:
            return LoadBalancerModel9

        def build(self) -> "LoadBalancerModel9":
            return LoadBalancerModel9(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: Optional[ConsistentHash], /
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Literal[
                "UNSPECIFIED",
                "LEAST_CONN",
                "RANDOM",
                "PASSTHROUGH",
                "ROUND_ROBIN",
                "LEAST_REQUEST",
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel9.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel9.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel9."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel9", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel9.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[Optional[ConsistentHash], Field(alias="consistentHash")] = None
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Literal[
        "UNSPECIFIED",
        "LEAST_CONN",
        "RANDOM",
        "PASSTHROUGH",
        "ROUND_ROBIN",
        "LEAST_REQUEST",
    ]
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class LoadBalancerModel10(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LoadBalancerModel10"]:
            return LoadBalancerModel10

        def build(self) -> "LoadBalancerModel10":
            return LoadBalancerModel10(**self._attrs)

        @overload
        def consistent_hash(
            self, value_or_callback: ConsistentHash, /
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def consistent_hash(
            self,
            value_or_callback: Callable[
                [ConsistentHash.Builder], ConsistentHash.Builder | ConsistentHash
            ],
            /,
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def consistent_hash(
            self, value_or_callback: Never = ...
        ) -> "ConsistentHash.BuilderContext": ...

        def consistent_hash(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConsistentHash.BuilderContext()
                context._parent_builder = self
                context._field_name = "consistent_hash"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsistentHash.builder())
                if isinstance(output, ConsistentHash.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consistent_hash", value)

        @overload
        def locality_lb_setting(
            self, value_or_callback: Optional[LocalityLbSetting], /
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def locality_lb_setting(
            self,
            value_or_callback: Callable[
                [LocalityLbSetting.Builder],
                LocalityLbSetting.Builder | LocalityLbSetting,
            ],
            /,
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def locality_lb_setting(
            self, value_or_callback: Never = ...
        ) -> "LocalityLbSetting.BuilderContext": ...

        def locality_lb_setting(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LocalityLbSetting.BuilderContext()
                context._parent_builder = self
                context._field_name = "locality_lb_setting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LocalityLbSetting.builder())
                if isinstance(output, LocalityLbSetting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("locality_lb_setting", value)

        def simple(
            self,
            value: Optional[
                Literal[
                    "UNSPECIFIED",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH",
                    "ROUND_ROBIN",
                    "LEAST_REQUEST",
                ]
            ],
            /,
        ) -> Self:
            """
            Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
            """
            return self._set("simple", value)

        @overload
        def warmup(
            self, value_or_callback: Optional[Warmup], /
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def warmup(
            self,
            value_or_callback: Callable[[Warmup.Builder], Warmup.Builder | Warmup],
            /,
        ) -> "LoadBalancerModel10.Builder": ...

        @overload
        def warmup(self, value_or_callback: Never = ...) -> "Warmup.BuilderContext": ...

        def warmup(self, value_or_callback=None, /):
            """
            Represents the warmup configuration of Service.
            """
            if self._in_context and value_or_callback is None:
                context = Warmup.BuilderContext()
                context._parent_builder = self
                context._field_name = "warmup"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Warmup.builder())
                if isinstance(output, Warmup.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("warmup", value)

        def warmup_duration_secs(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use `warmup` instead.
            """
            return self._set("warmup_duration_secs", value)

    class BuilderContext(BuilderContextBase["LoadBalancerModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LoadBalancerModel10.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LoadBalancerModel10."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LoadBalancerModel10", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LoadBalancerModel10.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    consistent_hash: Annotated[ConsistentHash, Field(alias="consistentHash")]
    locality_lb_setting: Annotated[
        Optional[LocalityLbSetting], Field(alias="localityLbSetting")
    ] = None
    simple: Optional[
        Literal[
            "UNSPECIFIED",
            "LEAST_CONN",
            "RANDOM",
            "PASSTHROUGH",
            "ROUND_ROBIN",
            "LEAST_REQUEST",
        ]
    ] = None
    """
    Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
    """
    warmup: Optional[Warmup] = None
    """
    Represents the warmup configuration of Service.
    """
    warmup_duration_secs: Annotated[Optional[str], Field(alias="warmupDurationSecs")] = None
    """
    Deprecated: use `warmup` instead.
    """


class WorkloadSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadSelector"]:
            return WorkloadSelector

        def build(self) -> "WorkloadSelector":
            return WorkloadSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["WorkloadSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
    """


class DestinationRuleSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DestinationRuleSpec"]:
            return DestinationRuleSpec

        def build(self) -> "DestinationRuleSpec":
            return DestinationRuleSpec(**self._attrs)

        def export_to(self, value: Optional[List[str]], /) -> Self:
            """
            A list of namespaces to which this destination rule is exported.
            """
            return self._set("export_to", value)

        def host(self, value: str, /) -> Self:
            """
            The name of a service from the service registry.
            """
            return self._set("host", value)

        @overload
        def subsets(self, value_or_callback: List[Subset], /) -> "DestinationRuleSpec.Builder": ...

        @overload
        def subsets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subset, Subset.Builder]],
                GenericListBuilder[Subset, Subset.Builder] | List[Subset],
            ],
            /,
        ) -> "DestinationRuleSpec.Builder": ...

        @overload
        def subsets(self, value_or_callback: Never = ...) -> ListBuilderContext[Subset.Builder]: ...

        def subsets(self, value_or_callback=None, /):
            """
            One or more named sets that represent individual versions of a service.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subset.Builder]()
                context._parent_builder = self
                context._field_name = "subsets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subset.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subsets", value)

        @overload
        def traffic_policy(
            self, value_or_callback: Optional[TrafficPolicy], /
        ) -> "DestinationRuleSpec.Builder": ...

        @overload
        def traffic_policy(
            self,
            value_or_callback: Callable[
                [TrafficPolicy.Builder], TrafficPolicy.Builder | TrafficPolicy
            ],
            /,
        ) -> "DestinationRuleSpec.Builder": ...

        @overload
        def traffic_policy(
            self, value_or_callback: Never = ...
        ) -> "TrafficPolicy.BuilderContext": ...

        def traffic_policy(self, value_or_callback=None, /):
            """
            Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
            """
            if self._in_context and value_or_callback is None:
                context = TrafficPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "traffic_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TrafficPolicy.builder())
                if isinstance(output, TrafficPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic_policy", value)

        @overload
        def workload_selector(
            self, value_or_callback: Optional[WorkloadSelector], /
        ) -> "DestinationRuleSpec.Builder": ...

        @overload
        def workload_selector(
            self,
            value_or_callback: Callable[
                [WorkloadSelector.Builder], WorkloadSelector.Builder | WorkloadSelector
            ],
            /,
        ) -> "DestinationRuleSpec.Builder": ...

        @overload
        def workload_selector(
            self, value_or_callback: Never = ...
        ) -> "WorkloadSelector.BuilderContext": ...

        def workload_selector(self, value_or_callback=None, /):
            """
            Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
            """
            if self._in_context and value_or_callback is None:
                context = WorkloadSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "workload_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadSelector.builder())
                if isinstance(output, WorkloadSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("workload_selector", value)

    class BuilderContext(BuilderContextBase["DestinationRuleSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DestinationRuleSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DestinationRuleSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DestinationRuleSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DestinationRuleSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    export_to: Annotated[Optional[List[str]], Field(alias="exportTo")] = None
    """
    A list of namespaces to which this destination rule is exported.
    """
    host: str
    """
    The name of a service from the service registry.
    """
    subsets: Optional[List[Subset]] = None
    """
    One or more named sets that represent individual versions of a service.
    """
    traffic_policy: Annotated[Optional[TrafficPolicy], Field(alias="trafficPolicy")] = None
    """
    Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
    """
    workload_selector: Annotated[Optional[WorkloadSelector], Field(alias="workloadSelector")] = None
    """
    Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Unique, one-word, CamelCase reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the type of the condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    Last time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    Last time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    Unique, one-word, CamelCase reason for the condition's last transition.
    """
    status: Optional[str] = None
    """
    Status is the status of the condition.
    """
    type: Optional[str] = None
    """
    Type is the type of the condition.
    """


class MessageType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MessageType"]:
            return MessageType

        def build(self) -> "MessageType":
            return MessageType(**self._attrs)

        def code(self, value: Optional[str], /) -> Self:
            """
            A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
            """
            return self._set("code", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            A human-readable name for the message type.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["MessageType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MessageType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MessageType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MessageType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MessageType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    code: Optional[str] = None
    """
    A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
    """
    name: Optional[str] = None
    """
    A human-readable name for the message type.
    """


class ValidationMessage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValidationMessage"]:
            return ValidationMessage

        def build(self) -> "ValidationMessage":
            return ValidationMessage(**self._attrs)

        def documentation_url(self, value: Optional[str], /) -> Self:
            """
            A url pointing to the Istio documentation for this specific error type.
            """
            return self._set("documentation_url", value)

        def level(self, value: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]], /) -> Self:
            """
            Represents how severe a message is.

            Valid Options: UNKNOWN, ERROR, WARNING, INFO
            """
            return self._set("level", value)

        @overload
        def type(
            self, value_or_callback: Optional[MessageType], /
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(
            self,
            value_or_callback: Callable[[MessageType.Builder], MessageType.Builder | MessageType],
            /,
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(self, value_or_callback: Never = ...) -> "MessageType.BuilderContext": ...

        def type(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MessageType.BuilderContext()
                context._parent_builder = self
                context._field_name = "type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MessageType.builder())
                if isinstance(output, MessageType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ValidationMessage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValidationMessage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValidationMessage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValidationMessage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValidationMessage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    documentation_url: Annotated[Optional[str], Field(alias="documentationUrl")] = None
    """
    A url pointing to the Istio documentation for this specific error type.
    """
    level: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]] = None
    """
    Represents how severe a message is.

    Valid Options: UNKNOWN, ERROR, WARNING, INFO
    """
    type: Annotated[
        Optional[MessageType],
        Field(title="cloudcoil.models.istio.networking.v1.MessageType"),
    ] = None


class DestinationRuleStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DestinationRuleStatus"]:
            return DestinationRuleStatus

        def build(self) -> "DestinationRuleStatus":
            return DestinationRuleStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "DestinationRuleStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "DestinationRuleStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "DestinationRuleStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "DestinationRuleStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["DestinationRuleStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DestinationRuleStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DestinationRuleStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DestinationRuleStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DestinationRuleStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class PortModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortModel"]:
            return PortModel

        def build(self) -> "PortModel":
            return PortModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Label assigned to the port.
            """
            return self._set("name", value)

        def number(self, value: int, /) -> Self:
            """
            A valid non-negative integer port number.
            """
            return self._set("number", value)

        def protocol(self, value: str, /) -> Self:
            """
            The protocol exposed on the port.
            """
            return self._set("protocol", value)

        def target_port(self, value: Optional[int], /) -> Self:
            return self._set("target_port", value)

    class BuilderContext(BuilderContextBase["PortModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Label assigned to the port.
    """
    number: Annotated[int, Field(ge=0, le=4294967295)]
    """
    A valid non-negative integer port number.
    """
    protocol: str
    """
    The protocol exposed on the port.
    """
    target_port: Annotated[Optional[int], Field(alias="targetPort", ge=0, le=4294967295)] = None


class TlsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsModel"]:
            return TlsModel

        def build(self) -> "TlsModel":
            return TlsModel(**self._attrs)

        def ca_certificates(self, value: Optional[str], /) -> Self:
            """
            REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
            """
            return self._set("ca_certificates", value)

        def ca_crl(self, value: Optional[str], /) -> Self:
            """
            OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
            """
            return self._set("ca_crl", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            Optional: If specified, only support the specified cipher list.
            """
            return self._set("cipher_suites", value)

        def credential_name(self, value: Optional[str], /) -> Self:
            """
            For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
            """
            return self._set("credential_name", value)

        def https_redirect(self, value: Optional[bool], /) -> Self:
            """
            If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
            """
            return self._set("https_redirect", value)

        def max_protocol_version(
            self,
            value: Optional[Literal["TLS_AUTO", "TLSV1_0", "TLSV1_1", "TLSV1_2", "TLSV1_3"]],
            /,
        ) -> Self:
            """
            Optional: Maximum TLS protocol version.

            Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
            """
            return self._set("max_protocol_version", value)

        def min_protocol_version(
            self,
            value: Optional[Literal["TLS_AUTO", "TLSV1_0", "TLSV1_1", "TLSV1_2", "TLSV1_3"]],
            /,
        ) -> Self:
            """
            Optional: Minimum TLS protocol version.

            Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
            """
            return self._set("min_protocol_version", value)

        def mode(
            self,
            value: Optional[
                Literal[
                    "PASSTHROUGH",
                    "SIMPLE",
                    "MUTUAL",
                    "AUTO_PASSTHROUGH",
                    "ISTIO_MUTUAL",
                    "OPTIONAL_MUTUAL",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional: Indicates whether connections to this port should be secured using TLS.

            Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
            """
            return self._set("mode", value)

        def private_key(self, value: Optional[str], /) -> Self:
            """
            REQUIRED if mode is `SIMPLE` or `MUTUAL`.
            """
            return self._set("private_key", value)

        def server_certificate(self, value: Optional[str], /) -> Self:
            """
            REQUIRED if mode is `SIMPLE` or `MUTUAL`.
            """
            return self._set("server_certificate", value)

        def subject_alt_names(self, value: Optional[List[str]], /) -> Self:
            """
            A list of alternate names to verify the subject identity in the certificate presented by the client.
            """
            return self._set("subject_alt_names", value)

        def verify_certificate_hash(self, value: Optional[List[str]], /) -> Self:
            """
            An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
            """
            return self._set("verify_certificate_hash", value)

        def verify_certificate_spki(self, value: Optional[List[str]], /) -> Self:
            """
            An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
            """
            return self._set("verify_certificate_spki", value)

    class BuilderContext(BuilderContextBase["TlsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_certificates: Annotated[Optional[str], Field(alias="caCertificates")] = None
    """
    REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
    """
    ca_crl: Annotated[Optional[str], Field(alias="caCrl")] = None
    """
    OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    Optional: If specified, only support the specified cipher list.
    """
    credential_name: Annotated[Optional[str], Field(alias="credentialName")] = None
    """
    For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
    """
    https_redirect: Annotated[Optional[bool], Field(alias="httpsRedirect")] = None
    """
    If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
    """
    max_protocol_version: Annotated[
        Optional[Literal["TLS_AUTO", "TLSV1_0", "TLSV1_1", "TLSV1_2", "TLSV1_3"]],
        Field(alias="maxProtocolVersion"),
    ] = None
    """
    Optional: Maximum TLS protocol version.

    Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
    """
    min_protocol_version: Annotated[
        Optional[Literal["TLS_AUTO", "TLSV1_0", "TLSV1_1", "TLSV1_2", "TLSV1_3"]],
        Field(alias="minProtocolVersion"),
    ] = None
    """
    Optional: Minimum TLS protocol version.

    Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
    """
    mode: Optional[
        Literal[
            "PASSTHROUGH",
            "SIMPLE",
            "MUTUAL",
            "AUTO_PASSTHROUGH",
            "ISTIO_MUTUAL",
            "OPTIONAL_MUTUAL",
        ]
    ] = None
    """
    Optional: Indicates whether connections to this port should be secured using TLS.

    Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
    """
    private_key: Annotated[Optional[str], Field(alias="privateKey")] = None
    """
    REQUIRED if mode is `SIMPLE` or `MUTUAL`.
    """
    server_certificate: Annotated[Optional[str], Field(alias="serverCertificate")] = None
    """
    REQUIRED if mode is `SIMPLE` or `MUTUAL`.
    """
    subject_alt_names: Annotated[Optional[List[str]], Field(alias="subjectAltNames")] = None
    """
    A list of alternate names to verify the subject identity in the certificate presented by the client.
    """
    verify_certificate_hash: Annotated[
        Optional[List[str]], Field(alias="verifyCertificateHash")
    ] = None
    """
    An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
    """
    verify_certificate_spki: Annotated[
        Optional[List[str]], Field(alias="verifyCertificateSpki")
    ] = None
    """
    An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
    """


class Server(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Server"]:
            return Server

        def build(self) -> "Server":
            return Server(**self._attrs)

        def bind(self, value: Optional[str], /) -> Self:
            """
            The ip or the Unix domain socket to which the listener should be bound to.
            """
            return self._set("bind", value)

        def default_endpoint(self, value: Optional[str], /) -> Self:
            return self._set("default_endpoint", value)

        def hosts(self, value: List[str], /) -> Self:
            """
            One or more hosts exposed by this gateway.
            """
            return self._set("hosts", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            An optional name of the server, when set must be unique across all servers.
            """
            return self._set("name", value)

        @overload
        def port(self, value_or_callback: PortModel, /) -> "Server.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel.Builder], PortModel.Builder | PortModel],
            /,
        ) -> "Server.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            The Port on which the proxy should listen for incoming connections.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel.builder())
                if isinstance(output, PortModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        @overload
        def tls(self, value_or_callback: Optional[TlsModel], /) -> "Server.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel.Builder], TlsModel.Builder | TlsModel],
            /,
        ) -> "Server.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            Set of TLS related options that govern the server's behavior.
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel.builder())
                if isinstance(output, TlsModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["Server.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Server.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Server."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Server", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Server.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bind: Optional[str] = None
    """
    The ip or the Unix domain socket to which the listener should be bound to.
    """
    default_endpoint: Annotated[Optional[str], Field(alias="defaultEndpoint")] = None
    hosts: List[str]
    """
    One or more hosts exposed by this gateway.
    """
    name: Optional[str] = None
    """
    An optional name of the server, when set must be unique across all servers.
    """
    port: PortModel
    """
    The Port on which the proxy should listen for incoming connections.
    """
    tls: Optional[TlsModel] = None
    """
    Set of TLS related options that govern the server's behavior.
    """


class GatewaySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GatewaySpec"]:
            return GatewaySpec

        def build(self) -> "GatewaySpec":
            return GatewaySpec(**self._attrs)

        def selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
            """
            return self._set("selector", value)

        @overload
        def servers(self, value_or_callback: List[Server], /) -> "GatewaySpec.Builder": ...

        @overload
        def servers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Server, Server.Builder]],
                GenericListBuilder[Server, Server.Builder] | List[Server],
            ],
            /,
        ) -> "GatewaySpec.Builder": ...

        @overload
        def servers(self, value_or_callback: Never = ...) -> ListBuilderContext[Server.Builder]: ...

        def servers(self, value_or_callback=None, /):
            """
            A list of server specifications.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Server.Builder]()
                context._parent_builder = self
                context._field_name = "servers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Server.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("servers", value)

    class BuilderContext(BuilderContextBase["GatewaySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GatewaySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GatewaySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GatewaySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GatewaySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    selector: Optional[Dict[str, str]] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
    """
    servers: Optional[List[Server]] = None
    """
    A list of server specifications.
    """


class GatewayStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GatewayStatus"]:
            return GatewayStatus

        def build(self) -> "GatewayStatus":
            return GatewayStatus(**self._attrs)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "GatewayStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "GatewayStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "GatewayStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "GatewayStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["GatewayStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GatewayStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GatewayStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GatewayStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GatewayStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class Address(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Address":
            value = cast(str, self._value)
            return Address(value)

    root: Annotated[str, Field(max_length=64)]

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()


class Endpoint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Endpoint"]:
            return Endpoint

        def build(self) -> "Endpoint":
            return Endpoint(**self._attrs)

        def address(self, value: Optional[str], /) -> Self:
            """
            Address associated with the network endpoint without the port.
            """
            return self._set("address", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels associated with the endpoint.
            """
            return self._set("labels", value)

        def locality(self, value: Optional[str], /) -> Self:
            """
            The locality associated with the endpoint.
            """
            return self._set("locality", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            Network enables Istio to group endpoints resident in the same L3 domain/network.
            """
            return self._set("network", value)

        def ports(self, value: Optional[Dict[str, int]], /) -> Self:
            """
            Set of ports associated with the endpoint.
            """
            return self._set("ports", value)

        def service_account(self, value: Optional[str], /) -> Self:
            """
            The service account associated with the workload if a sidecar is present in the workload.
            """
            return self._set("service_account", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            The load balancing weight associated with the endpoint.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Endpoint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Endpoint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Endpoint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Endpoint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Endpoint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Annotated[Optional[str], Field(max_length=256)] = None
    """
    Address associated with the network endpoint without the port.
    """
    labels: Optional[Dict[str, str]] = None
    """
    One or more labels associated with the endpoint.
    """
    locality: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    The locality associated with the endpoint.
    """
    network: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    Network enables Istio to group endpoints resident in the same L3 domain/network.
    """
    ports: Optional[Dict[str, int]] = None
    """
    Set of ports associated with the endpoint.
    """
    service_account: Annotated[Optional[str], Field(alias="serviceAccount", max_length=253)] = None
    """
    The service account associated with the workload if a sidecar is present in the workload.
    """
    weight: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    The load balancing weight associated with the endpoint.
    """


class PortModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortModel1"]:
            return PortModel1

        def build(self) -> "PortModel1":
            return PortModel1(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Label assigned to the port.
            """
            return self._set("name", value)

        def number(self, value: int, /) -> Self:
            """
            A valid non-negative integer port number.
            """
            return self._set("number", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol exposed on the port.
            """
            return self._set("protocol", value)

        def target_port(self, value: Optional[int], /) -> Self:
            """
            The port number on the endpoint where the traffic will be received.
            """
            return self._set("target_port", value)

    class BuilderContext(BuilderContextBase["PortModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(max_length=256)]
    """
    Label assigned to the port.
    """
    number: Annotated[int, Field(ge=0, le=4294967295)]
    """
    A valid non-negative integer port number.
    """
    protocol: Annotated[Optional[str], Field(max_length=256)] = None
    """
    The protocol exposed on the port.
    """
    target_port: Annotated[Optional[int], Field(alias="targetPort", ge=0, le=4294967295)] = None
    """
    The port number on the endpoint where the traffic will be received.
    """


class WorkloadSelectorModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadSelectorModel"]:
            return WorkloadSelectorModel

        def build(self) -> "WorkloadSelectorModel":
            return WorkloadSelectorModel(**self._attrs)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
            """
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["WorkloadSelectorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadSelectorModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadSelectorModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadSelectorModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadSelectorModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    labels: Optional[Dict[str, str]] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
    """


class ServiceEntrySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceEntrySpec"]:
            return ServiceEntrySpec

        def build(self) -> "ServiceEntrySpec":
            return ServiceEntrySpec(**self._attrs)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "ServiceEntrySpec.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "ServiceEntrySpec.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            The virtual IP addresses associated with the service.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        @overload
        def endpoints(self, value_or_callback: List[Endpoint], /) -> "ServiceEntrySpec.Builder": ...

        @overload
        def endpoints(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Endpoint, Endpoint.Builder]],
                GenericListBuilder[Endpoint, Endpoint.Builder] | List[Endpoint],
            ],
            /,
        ) -> "ServiceEntrySpec.Builder": ...

        @overload
        def endpoints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Endpoint.Builder]: ...

        def endpoints(self, value_or_callback=None, /):
            """
            One or more endpoints associated with the service.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Endpoint.Builder]()
                context._parent_builder = self
                context._field_name = "endpoints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Endpoint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("endpoints", value)

        def export_to(self, value: Optional[List[str]], /) -> Self:
            """
            A list of namespaces to which this service is exported.
            """
            return self._set("export_to", value)

        def hosts(self, value: List[str], /) -> Self:
            """
            The hosts associated with the ServiceEntry.
            """
            return self._set("hosts", value)

        def location(self, value: Optional[Literal["MESH_EXTERNAL", "MESH_INTERNAL"]], /) -> Self:
            """
            Specify whether the service should be considered external to the mesh or part of the mesh.

            Valid Options: MESH_EXTERNAL, MESH_INTERNAL
            """
            return self._set("location", value)

        @overload
        def ports(self, value_or_callback: List[PortModel1], /) -> "ServiceEntrySpec.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PortModel1, PortModel1.Builder]],
                GenericListBuilder[PortModel1, PortModel1.Builder] | List[PortModel1],
            ],
            /,
        ) -> "ServiceEntrySpec.Builder": ...

        @overload
        def ports(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PortModel1.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            The ports associated with the external service.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PortModel1.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        def resolution(
            self,
            value: Optional[Literal["NONE", "STATIC", "DNS", "DNS_ROUND_ROBIN"]],
            /,
        ) -> Self:
            """
            Service resolution mode for the hosts.

            Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
            """
            return self._set("resolution", value)

        def subject_alt_names(self, value: Optional[List[str]], /) -> Self:
            """
            If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
            """
            return self._set("subject_alt_names", value)

        @overload
        def workload_selector(
            self, value_or_callback: Optional[WorkloadSelectorModel], /
        ) -> "ServiceEntrySpec.Builder": ...

        @overload
        def workload_selector(
            self,
            value_or_callback: Callable[
                [WorkloadSelectorModel.Builder],
                WorkloadSelectorModel.Builder | WorkloadSelectorModel,
            ],
            /,
        ) -> "ServiceEntrySpec.Builder": ...

        @overload
        def workload_selector(
            self, value_or_callback: Never = ...
        ) -> "WorkloadSelectorModel.BuilderContext": ...

        def workload_selector(self, value_or_callback=None, /):
            """
            Applicable only for MESH_INTERNAL services.
            """
            if self._in_context and value_or_callback is None:
                context = WorkloadSelectorModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "workload_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadSelectorModel.builder())
                if isinstance(output, WorkloadSelectorModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("workload_selector", value)

    class BuilderContext(BuilderContextBase["ServiceEntrySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceEntrySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceEntrySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceEntrySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceEntrySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    addresses: Annotated[Optional[List[Address]], Field(max_length=256)] = None
    """
    The virtual IP addresses associated with the service.
    """
    endpoints: Annotated[Optional[List[Endpoint]], Field(max_length=4096)] = None
    """
    One or more endpoints associated with the service.
    """
    export_to: Annotated[Optional[List[str]], Field(alias="exportTo")] = None
    """
    A list of namespaces to which this service is exported.
    """
    hosts: Annotated[List[str], Field(max_length=256, min_length=1)]
    """
    The hosts associated with the ServiceEntry.
    """
    location: Optional[Literal["MESH_EXTERNAL", "MESH_INTERNAL"]] = None
    """
    Specify whether the service should be considered external to the mesh or part of the mesh.

    Valid Options: MESH_EXTERNAL, MESH_INTERNAL
    """
    ports: Annotated[Optional[List[PortModel1]], Field(max_length=256)] = None
    """
    The ports associated with the external service.
    """
    resolution: Optional[Literal["NONE", "STATIC", "DNS", "DNS_ROUND_ROBIN"]] = None
    """
    Service resolution mode for the hosts.

    Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
    """
    subject_alt_names: Annotated[Optional[List[str]], Field(alias="subjectAltNames")] = None
    """
    If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
    """
    workload_selector: Annotated[
        Optional[WorkloadSelectorModel], Field(alias="workloadSelector")
    ] = None
    """
    Applicable only for MESH_INTERNAL services.
    """


class ServiceEntryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceEntryStatus"]:
            return ServiceEntryStatus

        def build(self) -> "ServiceEntryStatus":
            return ServiceEntryStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ServiceEntryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ServiceEntryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "ServiceEntryStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "ServiceEntryStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["ServiceEntryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceEntryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceEntryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceEntryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceEntryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class PortModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortModel2"]:
            return PortModel2

        def build(self) -> "PortModel2":
            return PortModel2(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Label assigned to the port.
            """
            return self._set("name", value)

        def number(self, value: Optional[int], /) -> Self:
            """
            A valid non-negative integer port number.
            """
            return self._set("number", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The protocol exposed on the port.
            """
            return self._set("protocol", value)

        def target_port(self, value: Optional[int], /) -> Self:
            return self._set("target_port", value)

    class BuilderContext(BuilderContextBase["PortModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    Label assigned to the port.
    """
    number: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    A valid non-negative integer port number.
    """
    protocol: Optional[str] = None
    """
    The protocol exposed on the port.
    """
    target_port: Annotated[Optional[int], Field(alias="targetPort", ge=0, le=4294967295)] = None


class Egres(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Egres"]:
            return Egres

        def build(self) -> "Egres":
            return Egres(**self._attrs)

        def bind(self, value: Optional[str], /) -> Self:
            """
            The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
            """
            return self._set("bind", value)

        def capture_mode(self, value: Optional[Literal["DEFAULT", "IPTABLES", "NONE"]], /) -> Self:
            """
            When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).

            Valid Options: DEFAULT, IPTABLES, NONE
            """
            return self._set("capture_mode", value)

        def hosts(self, value: List[str], /) -> Self:
            """
            One or more service hosts exposed by the listener in `namespace/dnsName` format.
            """
            return self._set("hosts", value)

        @overload
        def port(self, value_or_callback: Optional[PortModel2], /) -> "Egres.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel2.Builder], PortModel2.Builder | PortModel2],
            /,
        ) -> "Egres.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel2.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            The port associated with the listener.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel2.builder())
                if isinstance(output, PortModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["Egres.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Egres.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Egres."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Egres", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Egres.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bind: Optional[str] = None
    """
    The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
    """
    capture_mode: Annotated[
        Optional[Literal["DEFAULT", "IPTABLES", "NONE"]], Field(alias="captureMode")
    ] = None
    """
    When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).

    Valid Options: DEFAULT, IPTABLES, NONE
    """
    hosts: List[str]
    """
    One or more service hosts exposed by the listener in `namespace/dnsName` format.
    """
    port: Optional[PortModel2] = None
    """
    The port associated with the listener.
    """


class InboundConnectionPool(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InboundConnectionPool"]:
            return InboundConnectionPool

        def build(self) -> "InboundConnectionPool":
            return InboundConnectionPool(**self._attrs)

        @overload
        def http(self, value_or_callback: Optional[Http], /) -> "InboundConnectionPool.Builder": ...

        @overload
        def http(
            self, value_or_callback: Callable[[Http.Builder], Http.Builder | Http], /
        ) -> "InboundConnectionPool.Builder": ...

        @overload
        def http(self, value_or_callback: Never = ...) -> "Http.BuilderContext": ...

        def http(self, value_or_callback=None, /):
            """
            HTTP connection pool settings.
            """
            if self._in_context and value_or_callback is None:
                context = Http.BuilderContext()
                context._parent_builder = self
                context._field_name = "http"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Http.builder())
                if isinstance(output, Http.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http", value)

        @overload
        def tcp(self, value_or_callback: Optional[Tcp], /) -> "InboundConnectionPool.Builder": ...

        @overload
        def tcp(
            self, value_or_callback: Callable[[Tcp.Builder], Tcp.Builder | Tcp], /
        ) -> "InboundConnectionPool.Builder": ...

        @overload
        def tcp(self, value_or_callback: Never = ...) -> "Tcp.BuilderContext": ...

        def tcp(self, value_or_callback=None, /):
            """
            Settings common to both HTTP and TCP upstream connections.
            """
            if self._in_context and value_or_callback is None:
                context = Tcp.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tcp.builder())
                if isinstance(output, Tcp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp", value)

    class BuilderContext(BuilderContextBase["InboundConnectionPool.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InboundConnectionPool.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InboundConnectionPool."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InboundConnectionPool", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InboundConnectionPool.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http: Optional[Http] = None
    """
    HTTP connection pool settings.
    """
    tcp: Optional[Tcp] = None
    """
    Settings common to both HTTP and TCP upstream connections.
    """


class Ingres(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ingres"]:
            return Ingres

        def build(self) -> "Ingres":
            return Ingres(**self._attrs)

        def bind(self, value: Optional[str], /) -> Self:
            """
            The IP(IPv4 or IPv6) to which the listener should be bound.
            """
            return self._set("bind", value)

        def capture_mode(self, value: Optional[Literal["DEFAULT", "IPTABLES", "NONE"]], /) -> Self:
            """
            The captureMode option dictates how traffic to the listener is expected to be captured (or not).

            Valid Options: DEFAULT, IPTABLES, NONE
            """
            return self._set("capture_mode", value)

        @overload
        def connection_pool(
            self, value_or_callback: Optional[ConnectionPool], /
        ) -> "Ingres.Builder": ...

        @overload
        def connection_pool(
            self,
            value_or_callback: Callable[
                [ConnectionPool.Builder], ConnectionPool.Builder | ConnectionPool
            ],
            /,
        ) -> "Ingres.Builder": ...

        @overload
        def connection_pool(
            self, value_or_callback: Never = ...
        ) -> "ConnectionPool.BuilderContext": ...

        def connection_pool(self, value_or_callback=None, /):
            """
            Settings controlling the volume of connections Envoy will accept from the network.
            """
            if self._in_context and value_or_callback is None:
                context = ConnectionPool.BuilderContext()
                context._parent_builder = self
                context._field_name = "connection_pool"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionPool.builder())
                if isinstance(output, ConnectionPool.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("connection_pool", value)

        def default_endpoint(self, value: Optional[str], /) -> Self:
            """
            The IP endpoint or Unix domain socket to which traffic should be forwarded to.
            """
            return self._set("default_endpoint", value)

        @overload
        def port(self, value_or_callback: PortModel2, /) -> "Ingres.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel2.Builder], PortModel2.Builder | PortModel2],
            /,
        ) -> "Ingres.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel2.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            The port associated with the listener.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel2.builder())
                if isinstance(output, PortModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        @overload
        def tls(self, value_or_callback: Optional[TlsModel], /) -> "Ingres.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel.Builder], TlsModel.Builder | TlsModel],
            /,
        ) -> "Ingres.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel.builder())
                if isinstance(output, TlsModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["Ingres.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ingres.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ingres."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ingres", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ingres.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bind: Optional[str] = None
    """
    The IP(IPv4 or IPv6) to which the listener should be bound.
    """
    capture_mode: Annotated[
        Optional[Literal["DEFAULT", "IPTABLES", "NONE"]], Field(alias="captureMode")
    ] = None
    """
    The captureMode option dictates how traffic to the listener is expected to be captured (or not).

    Valid Options: DEFAULT, IPTABLES, NONE
    """
    connection_pool: Annotated[Optional[ConnectionPool], Field(alias="connectionPool")] = None
    """
    Settings controlling the volume of connections Envoy will accept from the network.
    """
    default_endpoint: Annotated[Optional[str], Field(alias="defaultEndpoint")] = None
    """
    The IP endpoint or Unix domain socket to which traffic should be forwarded to.
    """
    port: PortModel2
    """
    The port associated with the listener.
    """
    tls: Optional[TlsModel] = None
    """
    Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
    """


class PortModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortModel3"]:
            return PortModel3

        def build(self) -> "PortModel3":
            return PortModel3(**self._attrs)

        def number(self, value: Optional[int], /) -> Self:
            return self._set("number", value)

    class BuilderContext(BuilderContextBase["PortModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    number: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None


class EgressProxy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EgressProxy"]:
            return EgressProxy

        def build(self) -> "EgressProxy":
            return EgressProxy(**self._attrs)

        def host(self, value: str, /) -> Self:
            """
            The name of a service from the service registry.
            """
            return self._set("host", value)

        @overload
        def port(self, value_or_callback: Optional[PortModel3], /) -> "EgressProxy.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel3.Builder], PortModel3.Builder | PortModel3],
            /,
        ) -> "EgressProxy.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel3.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            Specifies the port on the host that is being addressed.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel3.builder())
                if isinstance(output, PortModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        def subset(self, value: Optional[str], /) -> Self:
            """
            The name of a subset within the service.
            """
            return self._set("subset", value)

    class BuilderContext(BuilderContextBase["EgressProxy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EgressProxy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EgressProxy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EgressProxy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EgressProxy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: str
    """
    The name of a service from the service registry.
    """
    port: Optional[PortModel3] = None
    """
    Specifies the port on the host that is being addressed.
    """
    subset: Optional[str] = None
    """
    The name of a subset within the service.
    """


class OutboundTrafficPolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OutboundTrafficPolicy"]:
            return OutboundTrafficPolicy

        def build(self) -> "OutboundTrafficPolicy":
            return OutboundTrafficPolicy(**self._attrs)

        @overload
        def egress_proxy(
            self, value_or_callback: Optional[EgressProxy], /
        ) -> "OutboundTrafficPolicy.Builder": ...

        @overload
        def egress_proxy(
            self,
            value_or_callback: Callable[[EgressProxy.Builder], EgressProxy.Builder | EgressProxy],
            /,
        ) -> "OutboundTrafficPolicy.Builder": ...

        @overload
        def egress_proxy(self, value_or_callback: Never = ...) -> "EgressProxy.BuilderContext": ...

        def egress_proxy(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = EgressProxy.BuilderContext()
                context._parent_builder = self
                context._field_name = "egress_proxy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EgressProxy.builder())
                if isinstance(output, EgressProxy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("egress_proxy", value)

        def mode(self, value: Optional[Literal["REGISTRY_ONLY", "ALLOW_ANY"]], /) -> Self:
            """
            Valid Options: REGISTRY_ONLY, ALLOW_ANY
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["OutboundTrafficPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OutboundTrafficPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OutboundTrafficPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OutboundTrafficPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OutboundTrafficPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    egress_proxy: Annotated[Optional[EgressProxy], Field(alias="egressProxy")] = None
    mode: Optional[Literal["REGISTRY_ONLY", "ALLOW_ANY"]] = None
    """
    Valid Options: REGISTRY_ONLY, ALLOW_ANY
    """


class SidecarSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SidecarSpec"]:
            return SidecarSpec

        def build(self) -> "SidecarSpec":
            return SidecarSpec(**self._attrs)

        @overload
        def egress(self, value_or_callback: List[Egres], /) -> "SidecarSpec.Builder": ...

        @overload
        def egress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Egres, Egres.Builder]],
                GenericListBuilder[Egres, Egres.Builder] | List[Egres],
            ],
            /,
        ) -> "SidecarSpec.Builder": ...

        @overload
        def egress(self, value_or_callback: Never = ...) -> ListBuilderContext[Egres.Builder]: ...

        def egress(self, value_or_callback=None, /):
            """
            Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Egres.Builder]()
                context._parent_builder = self
                context._field_name = "egress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Egres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("egress", value)

        @overload
        def inbound_connection_pool(
            self, value_or_callback: Optional[InboundConnectionPool], /
        ) -> "SidecarSpec.Builder": ...

        @overload
        def inbound_connection_pool(
            self,
            value_or_callback: Callable[
                [InboundConnectionPool.Builder],
                InboundConnectionPool.Builder | InboundConnectionPool,
            ],
            /,
        ) -> "SidecarSpec.Builder": ...

        @overload
        def inbound_connection_pool(
            self, value_or_callback: Never = ...
        ) -> "InboundConnectionPool.BuilderContext": ...

        def inbound_connection_pool(self, value_or_callback=None, /):
            """
            Settings controlling the volume of connections Envoy will accept from the network.
            """
            if self._in_context and value_or_callback is None:
                context = InboundConnectionPool.BuilderContext()
                context._parent_builder = self
                context._field_name = "inbound_connection_pool"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InboundConnectionPool.builder())
                if isinstance(output, InboundConnectionPool.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("inbound_connection_pool", value)

        @overload
        def ingress(self, value_or_callback: List[Ingres], /) -> "SidecarSpec.Builder": ...

        @overload
        def ingress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ingres, Ingres.Builder]],
                GenericListBuilder[Ingres, Ingres.Builder] | List[Ingres],
            ],
            /,
        ) -> "SidecarSpec.Builder": ...

        @overload
        def ingress(self, value_or_callback: Never = ...) -> ListBuilderContext[Ingres.Builder]: ...

        def ingress(self, value_or_callback=None, /):
            """
            Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ingres.Builder]()
                context._parent_builder = self
                context._field_name = "ingress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ingres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress", value)

        @overload
        def outbound_traffic_policy(
            self, value_or_callback: Optional[OutboundTrafficPolicy], /
        ) -> "SidecarSpec.Builder": ...

        @overload
        def outbound_traffic_policy(
            self,
            value_or_callback: Callable[
                [OutboundTrafficPolicy.Builder],
                OutboundTrafficPolicy.Builder | OutboundTrafficPolicy,
            ],
            /,
        ) -> "SidecarSpec.Builder": ...

        @overload
        def outbound_traffic_policy(
            self, value_or_callback: Never = ...
        ) -> "OutboundTrafficPolicy.BuilderContext": ...

        def outbound_traffic_policy(self, value_or_callback=None, /):
            """
            Set the default behavior of the sidecar for handling outbound traffic from the application.
            """
            if self._in_context and value_or_callback is None:
                context = OutboundTrafficPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "outbound_traffic_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OutboundTrafficPolicy.builder())
                if isinstance(output, OutboundTrafficPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("outbound_traffic_policy", value)

        @overload
        def workload_selector(
            self, value_or_callback: Optional[WorkloadSelectorModel], /
        ) -> "SidecarSpec.Builder": ...

        @overload
        def workload_selector(
            self,
            value_or_callback: Callable[
                [WorkloadSelectorModel.Builder],
                WorkloadSelectorModel.Builder | WorkloadSelectorModel,
            ],
            /,
        ) -> "SidecarSpec.Builder": ...

        @overload
        def workload_selector(
            self, value_or_callback: Never = ...
        ) -> "WorkloadSelectorModel.BuilderContext": ...

        def workload_selector(self, value_or_callback=None, /):
            """
            Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
            """
            if self._in_context and value_or_callback is None:
                context = WorkloadSelectorModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "workload_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadSelectorModel.builder())
                if isinstance(output, WorkloadSelectorModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("workload_selector", value)

    class BuilderContext(BuilderContextBase["SidecarSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SidecarSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SidecarSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SidecarSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SidecarSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    egress: Optional[List[Egres]] = None
    """
    Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
    """
    inbound_connection_pool: Annotated[
        Optional[InboundConnectionPool], Field(alias="inboundConnectionPool")
    ] = None
    """
    Settings controlling the volume of connections Envoy will accept from the network.
    """
    ingress: Optional[List[Ingres]] = None
    """
    Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
    """
    outbound_traffic_policy: Annotated[
        Optional[OutboundTrafficPolicy], Field(alias="outboundTrafficPolicy")
    ] = None
    """
    Set the default behavior of the sidecar for handling outbound traffic from the application.
    """
    workload_selector: Annotated[
        Optional[WorkloadSelectorModel], Field(alias="workloadSelector")
    ] = None
    """
    Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
    """


class SidecarStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SidecarStatus"]:
            return SidecarStatus

        def build(self) -> "SidecarStatus":
            return SidecarStatus(**self._attrs)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "SidecarStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "SidecarStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "SidecarStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "SidecarStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["SidecarStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SidecarStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SidecarStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SidecarStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SidecarStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class AllowOrigins(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllowOrigins"]:
            return AllowOrigins

        def build(self) -> "AllowOrigins":
            return AllowOrigins(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AllowOrigins.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllowOrigins.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllowOrigins."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllowOrigins", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllowOrigins.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AllowOriginsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllowOriginsModel"]:
            return AllowOriginsModel

        def build(self) -> "AllowOriginsModel":
            return AllowOriginsModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AllowOriginsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllowOriginsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllowOriginsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllowOriginsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllowOriginsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AllowOriginsModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllowOriginsModel1"]:
            return AllowOriginsModel1

        def build(self) -> "AllowOriginsModel1":
            return AllowOriginsModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AllowOriginsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllowOriginsModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllowOriginsModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllowOriginsModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllowOriginsModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AllowOriginsModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllowOriginsModel2"]:
            return AllowOriginsModel2

        def build(self) -> "AllowOriginsModel2":
            return AllowOriginsModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AllowOriginsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllowOriginsModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllowOriginsModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllowOriginsModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllowOriginsModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class CorsPolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CorsPolicy"]:
            return CorsPolicy

        def build(self) -> "CorsPolicy":
            return CorsPolicy(**self._attrs)

        def allow_credentials(self, value: Optional[bool], /) -> Self:
            """
            Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
            """
            return self._set("allow_credentials", value)

        def allow_headers(self, value: Optional[List[str]], /) -> Self:
            """
            List of HTTP headers that can be used when requesting the resource.
            """
            return self._set("allow_headers", value)

        def allow_methods(self, value: Optional[List[str]], /) -> Self:
            """
            List of HTTP methods allowed to access the resource.
            """
            return self._set("allow_methods", value)

        def allow_origin(self, value: Optional[List[str]], /) -> Self:
            return self._set("allow_origin", value)

        def allow_origins(
            self,
            value: Optional[
                List[
                    Union[
                        AllowOrigins,
                        AllowOriginsModel,
                        AllowOriginsModel1,
                        AllowOriginsModel2,
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            String patterns that match allowed origins.
            """
            return self._set("allow_origins", value)

        def expose_headers(self, value: Optional[List[str]], /) -> Self:
            """
            A list of HTTP headers that the browsers are allowed to access.
            """
            return self._set("expose_headers", value)

        def max_age(self, value: Optional[str], /) -> Self:
            """
            Specifies how long the results of a preflight request can be cached.
            """
            return self._set("max_age", value)

        def unmatched_preflights(
            self, value: Optional[Literal["UNSPECIFIED", "FORWARD", "IGNORE"]], /
        ) -> Self:
            """
            Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.

            Valid Options: FORWARD, IGNORE
            """
            return self._set("unmatched_preflights", value)

    class BuilderContext(BuilderContextBase["CorsPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CorsPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CorsPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CorsPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CorsPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_credentials: Annotated[Optional[bool], Field(alias="allowCredentials")] = None
    """
    Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
    """
    allow_headers: Annotated[Optional[List[str]], Field(alias="allowHeaders")] = None
    """
    List of HTTP headers that can be used when requesting the resource.
    """
    allow_methods: Annotated[Optional[List[str]], Field(alias="allowMethods")] = None
    """
    List of HTTP methods allowed to access the resource.
    """
    allow_origin: Annotated[Optional[List[str]], Field(alias="allowOrigin")] = None
    allow_origins: Annotated[
        Optional[
            List[
                Union[
                    AllowOrigins,
                    AllowOriginsModel,
                    AllowOriginsModel1,
                    AllowOriginsModel2,
                ]
            ]
        ],
        Field(alias="allowOrigins"),
    ] = None
    """
    String patterns that match allowed origins.
    """
    expose_headers: Annotated[Optional[List[str]], Field(alias="exposeHeaders")] = None
    """
    A list of HTTP headers that the browsers are allowed to access.
    """
    max_age: Annotated[Optional[str], Field(alias="maxAge")] = None
    """
    Specifies how long the results of a preflight request can be cached.
    """
    unmatched_preflights: Annotated[
        Optional[Literal["UNSPECIFIED", "FORWARD", "IGNORE"]],
        Field(alias="unmatchedPreflights"),
    ] = None
    """
    Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.

    Valid Options: FORWARD, IGNORE
    """


class Delegate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delegate"]:
            return Delegate

        def build(self) -> "Delegate":
            return Delegate(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the name of the delegate VirtualService.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies the namespace where the delegate VirtualService resides.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Delegate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delegate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delegate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delegate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delegate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    Name specifies the name of the delegate VirtualService.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies the namespace where the delegate VirtualService resides.
    """


class Body(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Body"]:
            return Body

        def build(self) -> "Body":
            return Body(**self._attrs)

        def bytes(self, value: Optional[bytes], /) -> Self:
            """
            response body as base64 encoded bytes.
            """
            return self._set("bytes", value)

        def string(self, value: Optional[str], /) -> Self:
            return self._set("string", value)

    class BuilderContext(BuilderContextBase["Body.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Body.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Body."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Body", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Body.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bytes: Optional[bytes] = None
    """
    response body as base64 encoded bytes.
    """
    string: Optional[str] = None


class BodyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BodyModel"]:
            return BodyModel

        def build(self) -> "BodyModel":
            return BodyModel(**self._attrs)

        def bytes(self, value: Optional[bytes], /) -> Self:
            """
            response body as base64 encoded bytes.
            """
            return self._set("bytes", value)

        def string(self, value: str, /) -> Self:
            return self._set("string", value)

    class BuilderContext(BuilderContextBase["BodyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BodyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BodyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BodyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BodyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bytes: Optional[bytes] = None
    """
    response body as base64 encoded bytes.
    """
    string: str


class BodyModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BodyModel1"]:
            return BodyModel1

        def build(self) -> "BodyModel1":
            return BodyModel1(**self._attrs)

        def bytes(self, value: bytes, /) -> Self:
            """
            response body as base64 encoded bytes.
            """
            return self._set("bytes", value)

        def string(self, value: Optional[str], /) -> Self:
            return self._set("string", value)

    class BuilderContext(BuilderContextBase["BodyModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BodyModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BodyModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BodyModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BodyModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bytes: bytes
    """
    response body as base64 encoded bytes.
    """
    string: Optional[str] = None


class DirectResponse(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DirectResponse"]:
            return DirectResponse

        def build(self) -> "DirectResponse":
            return DirectResponse(**self._attrs)

        def body(self, value: Optional[Union[Body, BodyModel, BodyModel1]], /) -> Self:
            """
            Specifies the content of the response body.
            """
            return self._set("body", value)

        def status(self, value: int, /) -> Self:
            """
            Specifies the HTTP response status to be returned.
            """
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DirectResponse.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DirectResponse.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DirectResponse."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DirectResponse", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DirectResponse.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    body: Optional[Union[Body, BodyModel, BodyModel1]] = None
    """
    Specifies the content of the response body.
    """
    status: Annotated[int, Field(ge=0, le=4294967295)]
    """
    Specifies the HTTP response status to be returned.
    """


class Percentage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Percentage"]:
            return Percentage

        def build(self) -> "Percentage":
            return Percentage(**self._attrs)

        def value(self, value: Optional[float], /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Percentage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Percentage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Percentage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Percentage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Percentage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    value: Optional[float] = None


class Abort(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Abort"]:
            return Abort

        def build(self) -> "Abort":
            return Abort(**self._attrs)

        def grpc_status(self, value: Optional[str], /) -> Self:
            """
            GRPC status code to use to abort the request.
            """
            return self._set("grpc_status", value)

        def http2_error(self, value: Optional[str], /) -> Self:
            return self._set("http2_error", value)

        def http_status(self, value: Optional[int], /) -> Self:
            """
            HTTP status code to use to abort the Http request.
            """
            return self._set("http_status", value)

        @overload
        def percentage(self, value_or_callback: Optional[Percentage], /) -> "Abort.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "Abort.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests to be aborted with the error code provided.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["Abort.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Abort.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Abort."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Abort", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Abort.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    grpc_status: Annotated[Optional[str], Field(alias="grpcStatus")] = None
    """
    GRPC status code to use to abort the request.
    """
    http2_error: Annotated[Optional[str], Field(alias="http2Error")] = None
    http_status: Annotated[Optional[int], Field(alias="httpStatus")] = None
    """
    HTTP status code to use to abort the Http request.
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests to be aborted with the error code provided.
    """


class AbortModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AbortModel"]:
            return AbortModel

        def build(self) -> "AbortModel":
            return AbortModel(**self._attrs)

        def grpc_status(self, value: Optional[str], /) -> Self:
            """
            GRPC status code to use to abort the request.
            """
            return self._set("grpc_status", value)

        def http2_error(self, value: Optional[str], /) -> Self:
            return self._set("http2_error", value)

        def http_status(self, value: int, /) -> Self:
            """
            HTTP status code to use to abort the Http request.
            """
            return self._set("http_status", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "AbortModel.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "AbortModel.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests to be aborted with the error code provided.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["AbortModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AbortModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AbortModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AbortModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AbortModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    grpc_status: Annotated[Optional[str], Field(alias="grpcStatus")] = None
    """
    GRPC status code to use to abort the request.
    """
    http2_error: Annotated[Optional[str], Field(alias="http2Error")] = None
    http_status: Annotated[int, Field(alias="httpStatus")]
    """
    HTTP status code to use to abort the Http request.
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests to be aborted with the error code provided.
    """


class AbortModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AbortModel1"]:
            return AbortModel1

        def build(self) -> "AbortModel1":
            return AbortModel1(**self._attrs)

        def grpc_status(self, value: str, /) -> Self:
            """
            GRPC status code to use to abort the request.
            """
            return self._set("grpc_status", value)

        def http2_error(self, value: Optional[str], /) -> Self:
            return self._set("http2_error", value)

        def http_status(self, value: Optional[int], /) -> Self:
            """
            HTTP status code to use to abort the Http request.
            """
            return self._set("http_status", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "AbortModel1.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "AbortModel1.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests to be aborted with the error code provided.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["AbortModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AbortModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AbortModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AbortModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AbortModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    grpc_status: Annotated[str, Field(alias="grpcStatus")]
    """
    GRPC status code to use to abort the request.
    """
    http2_error: Annotated[Optional[str], Field(alias="http2Error")] = None
    http_status: Annotated[Optional[int], Field(alias="httpStatus")] = None
    """
    HTTP status code to use to abort the Http request.
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests to be aborted with the error code provided.
    """


class AbortModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AbortModel2"]:
            return AbortModel2

        def build(self) -> "AbortModel2":
            return AbortModel2(**self._attrs)

        def grpc_status(self, value: Optional[str], /) -> Self:
            """
            GRPC status code to use to abort the request.
            """
            return self._set("grpc_status", value)

        def http2_error(self, value: str, /) -> Self:
            return self._set("http2_error", value)

        def http_status(self, value: Optional[int], /) -> Self:
            """
            HTTP status code to use to abort the Http request.
            """
            return self._set("http_status", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "AbortModel2.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "AbortModel2.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests to be aborted with the error code provided.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["AbortModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AbortModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AbortModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AbortModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AbortModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    grpc_status: Annotated[Optional[str], Field(alias="grpcStatus")] = None
    """
    GRPC status code to use to abort the request.
    """
    http2_error: Annotated[str, Field(alias="http2Error")]
    http_status: Annotated[Optional[int], Field(alias="httpStatus")] = None
    """
    HTTP status code to use to abort the Http request.
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests to be aborted with the error code provided.
    """


class Delay(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delay"]:
            return Delay

        def build(self) -> "Delay":
            return Delay(**self._attrs)

        def exponential_delay(self, value: Optional[str], /) -> Self:
            return self._set("exponential_delay", value)

        def fixed_delay(self, value: Optional[str], /) -> Self:
            """
            Add a fixed delay before forwarding the request.
            """
            return self._set("fixed_delay", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Percentage of requests on which the delay will be injected (0-100).
            """
            return self._set("percent", value)

        @overload
        def percentage(self, value_or_callback: Optional[Percentage], /) -> "Delay.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "Delay.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests on which the delay will be injected.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["Delay.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delay.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delay."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delay", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delay.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exponential_delay: Annotated[Optional[str], Field(alias="exponentialDelay")] = None
    fixed_delay: Annotated[Optional[str], Field(alias="fixedDelay")] = None
    """
    Add a fixed delay before forwarding the request.
    """
    percent: Optional[int] = None
    """
    Percentage of requests on which the delay will be injected (0-100).
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests on which the delay will be injected.
    """


class DelayModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DelayModel"]:
            return DelayModel

        def build(self) -> "DelayModel":
            return DelayModel(**self._attrs)

        def exponential_delay(self, value: Optional[str], /) -> Self:
            return self._set("exponential_delay", value)

        def fixed_delay(self, value: str, /) -> Self:
            """
            Add a fixed delay before forwarding the request.
            """
            return self._set("fixed_delay", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Percentage of requests on which the delay will be injected (0-100).
            """
            return self._set("percent", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "DelayModel.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "DelayModel.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests on which the delay will be injected.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["DelayModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DelayModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DelayModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DelayModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DelayModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exponential_delay: Annotated[Optional[str], Field(alias="exponentialDelay")] = None
    fixed_delay: Annotated[str, Field(alias="fixedDelay")]
    """
    Add a fixed delay before forwarding the request.
    """
    percent: Optional[int] = None
    """
    Percentage of requests on which the delay will be injected (0-100).
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests on which the delay will be injected.
    """


class DelayModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DelayModel1"]:
            return DelayModel1

        def build(self) -> "DelayModel1":
            return DelayModel1(**self._attrs)

        def exponential_delay(self, value: str, /) -> Self:
            return self._set("exponential_delay", value)

        def fixed_delay(self, value: Optional[str], /) -> Self:
            """
            Add a fixed delay before forwarding the request.
            """
            return self._set("fixed_delay", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Percentage of requests on which the delay will be injected (0-100).
            """
            return self._set("percent", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "DelayModel1.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "DelayModel1.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of requests on which the delay will be injected.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["DelayModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DelayModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DelayModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DelayModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DelayModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exponential_delay: Annotated[str, Field(alias="exponentialDelay")]
    fixed_delay: Annotated[Optional[str], Field(alias="fixedDelay")] = None
    """
    Add a fixed delay before forwarding the request.
    """
    percent: Optional[int] = None
    """
    Percentage of requests on which the delay will be injected (0-100).
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of requests on which the delay will be injected.
    """


class Fault(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Fault"]:
            return Fault

        def build(self) -> "Fault":
            return Fault(**self._attrs)

        def abort(
            self, value: Optional[Union[Abort, AbortModel, AbortModel1, AbortModel2]], /
        ) -> Self:
            """
            Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
            """
            return self._set("abort", value)

        def delay(self, value: Optional[Union[Delay, DelayModel, DelayModel1]], /) -> Self:
            """
            Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
            """
            return self._set("delay", value)

    class BuilderContext(BuilderContextBase["Fault.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Fault.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Fault."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Fault", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Fault.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    abort: Optional[Union[Abort, AbortModel, AbortModel1, AbortModel2]] = None
    """
    Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
    """
    delay: Optional[Union[Delay, DelayModel, DelayModel1]] = None
    """
    Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
    """


class Request(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Request"]:
            return Request

        def build(self) -> "Request":
            return Request(**self._attrs)

        def add(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("add", value)

        def remove(self, value: Optional[List[str]], /) -> Self:
            return self._set("remove", value)

        def set(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("set", value)

    class BuilderContext(BuilderContextBase["Request.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Request.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Request."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Request", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Request.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add: Optional[Dict[str, str]] = None
    remove: Optional[List[str]] = None
    set: Optional[Dict[str, str]] = None


class Response(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Response"]:
            return Response

        def build(self) -> "Response":
            return Response(**self._attrs)

        def add(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("add", value)

        def remove(self, value: Optional[List[str]], /) -> Self:
            return self._set("remove", value)

        def set(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("set", value)

    class BuilderContext(BuilderContextBase["Response.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Response.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Response."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Response", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Response.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add: Optional[Dict[str, str]] = None
    remove: Optional[List[str]] = None
    set: Optional[Dict[str, str]] = None


class Headers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Headers"]:
            return Headers

        def build(self) -> "Headers":
            return Headers(**self._attrs)

        @overload
        def request(self, value_or_callback: Optional[Request], /) -> "Headers.Builder": ...

        @overload
        def request(
            self,
            value_or_callback: Callable[[Request.Builder], Request.Builder | Request],
            /,
        ) -> "Headers.Builder": ...

        @overload
        def request(self, value_or_callback: Never = ...) -> "Request.BuilderContext": ...

        def request(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Request.BuilderContext()
                context._parent_builder = self
                context._field_name = "request"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Request.builder())
                if isinstance(output, Request.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request", value)

        @overload
        def response(self, value_or_callback: Optional[Response], /) -> "Headers.Builder": ...

        @overload
        def response(
            self,
            value_or_callback: Callable[[Response.Builder], Response.Builder | Response],
            /,
        ) -> "Headers.Builder": ...

        @overload
        def response(self, value_or_callback: Never = ...) -> "Response.BuilderContext": ...

        def response(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Response.BuilderContext()
                context._parent_builder = self
                context._field_name = "response"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Response.builder())
                if isinstance(output, Response.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response", value)

    class BuilderContext(BuilderContextBase["Headers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Headers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Headers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Headers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Headers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    request: Optional[Request] = None
    response: Optional[Response] = None


class Authority(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Authority"]:
            return Authority

        def build(self) -> "Authority":
            return Authority(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["Authority.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Authority.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Authority."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Authority", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Authority.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AuthorityModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorityModel"]:
            return AuthorityModel

        def build(self) -> "AuthorityModel":
            return AuthorityModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AuthorityModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorityModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorityModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorityModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorityModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AuthorityModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorityModel1"]:
            return AuthorityModel1

        def build(self) -> "AuthorityModel1":
            return AuthorityModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AuthorityModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorityModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorityModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorityModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorityModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class AuthorityModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorityModel2"]:
            return AuthorityModel2

        def build(self) -> "AuthorityModel2":
            return AuthorityModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["AuthorityModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorityModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorityModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorityModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorityModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class HeadersModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HeadersModel"]:
            return HeadersModel

        def build(self) -> "HeadersModel":
            return HeadersModel(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["HeadersModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HeadersModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HeadersModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HeadersModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HeadersModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class HeadersModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HeadersModel1"]:
            return HeadersModel1

        def build(self) -> "HeadersModel1":
            return HeadersModel1(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["HeadersModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HeadersModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HeadersModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HeadersModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HeadersModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class HeadersModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HeadersModel2"]:
            return HeadersModel2

        def build(self) -> "HeadersModel2":
            return HeadersModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["HeadersModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HeadersModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HeadersModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HeadersModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HeadersModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class HeadersModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HeadersModel3"]:
            return HeadersModel3

        def build(self) -> "HeadersModel3":
            return HeadersModel3(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["HeadersModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HeadersModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HeadersModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HeadersModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HeadersModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class Method(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Method"]:
            return Method

        def build(self) -> "Method":
            return Method(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["Method.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Method.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Method."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Method", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Method.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class MethodModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MethodModel"]:
            return MethodModel

        def build(self) -> "MethodModel":
            return MethodModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["MethodModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MethodModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MethodModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MethodModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MethodModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class MethodModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MethodModel1"]:
            return MethodModel1

        def build(self) -> "MethodModel1":
            return MethodModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["MethodModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MethodModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MethodModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MethodModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MethodModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class MethodModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MethodModel2"]:
            return MethodModel2

        def build(self) -> "MethodModel2":
            return MethodModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["MethodModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MethodModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MethodModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MethodModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MethodModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class QueryParams(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueryParams"]:
            return QueryParams

        def build(self) -> "QueryParams":
            return QueryParams(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["QueryParams.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueryParams.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueryParams."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueryParams", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueryParams.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class QueryParamsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueryParamsModel"]:
            return QueryParamsModel

        def build(self) -> "QueryParamsModel":
            return QueryParamsModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["QueryParamsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueryParamsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueryParamsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueryParamsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueryParamsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class QueryParamsModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueryParamsModel1"]:
            return QueryParamsModel1

        def build(self) -> "QueryParamsModel1":
            return QueryParamsModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["QueryParamsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueryParamsModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueryParamsModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueryParamsModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueryParamsModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class QueryParamsModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueryParamsModel2"]:
            return QueryParamsModel2

        def build(self) -> "QueryParamsModel2":
            return QueryParamsModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["QueryParamsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueryParamsModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueryParamsModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueryParamsModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueryParamsModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class Scheme(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Scheme"]:
            return Scheme

        def build(self) -> "Scheme":
            return Scheme(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["Scheme.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Scheme.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Scheme."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Scheme", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Scheme.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class SchemeModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SchemeModel"]:
            return SchemeModel

        def build(self) -> "SchemeModel":
            return SchemeModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["SchemeModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SchemeModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SchemeModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SchemeModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SchemeModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class SchemeModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SchemeModel1"]:
            return SchemeModel1

        def build(self) -> "SchemeModel1":
            return SchemeModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["SchemeModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SchemeModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SchemeModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SchemeModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SchemeModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class SchemeModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SchemeModel2"]:
            return SchemeModel2

        def build(self) -> "SchemeModel2":
            return SchemeModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["SchemeModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SchemeModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SchemeModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SchemeModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SchemeModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class Uri(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Uri"]:
            return Uri

        def build(self) -> "Uri":
            return Uri(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["Uri.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Uri.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Uri."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Uri", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Uri.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class UriModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UriModel"]:
            return UriModel

        def build(self) -> "UriModel":
            return UriModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["UriModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UriModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UriModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UriModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UriModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class UriModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UriModel1"]:
            return UriModel1

        def build(self) -> "UriModel1":
            return UriModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["UriModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UriModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UriModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UriModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UriModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class UriModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UriModel2"]:
            return UriModel2

        def build(self) -> "UriModel2":
            return UriModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["UriModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UriModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UriModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UriModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UriModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class WithoutHeaders(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WithoutHeaders"]:
            return WithoutHeaders

        def build(self) -> "WithoutHeaders":
            return WithoutHeaders(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["WithoutHeaders.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WithoutHeaders.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WithoutHeaders."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WithoutHeaders", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WithoutHeaders.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class WithoutHeadersModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WithoutHeadersModel"]:
            return WithoutHeadersModel

        def build(self) -> "WithoutHeadersModel":
            return WithoutHeadersModel(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["WithoutHeadersModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WithoutHeadersModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WithoutHeadersModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WithoutHeadersModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WithoutHeadersModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str
    prefix: Optional[str] = None
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class WithoutHeadersModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WithoutHeadersModel1"]:
            return WithoutHeadersModel1

        def build(self) -> "WithoutHeadersModel1":
            return WithoutHeadersModel1(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: str, /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["WithoutHeadersModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WithoutHeadersModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WithoutHeadersModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WithoutHeadersModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WithoutHeadersModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: str
    regex: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class WithoutHeadersModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WithoutHeadersModel2"]:
            return WithoutHeadersModel2

        def build(self) -> "WithoutHeadersModel2":
            return WithoutHeadersModel2(**self._attrs)

        def exact(self, value: Optional[str], /) -> Self:
            return self._set("exact", value)

        def prefix(self, value: Optional[str], /) -> Self:
            return self._set("prefix", value)

        def regex(self, value: str, /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["WithoutHeadersModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WithoutHeadersModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WithoutHeadersModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WithoutHeadersModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WithoutHeadersModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: Optional[str] = None
    prefix: Optional[str] = None
    regex: str
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        def authority(
            self,
            value: Optional[Union[Authority, AuthorityModel, AuthorityModel1, AuthorityModel2]],
            /,
        ) -> Self:
            """
            HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("authority", value)

        def gateways(self, value: Optional[List[str]], /) -> Self:
            """
            Names of gateways where the rule should be applied.
            """
            return self._set("gateways", value)

        def headers(
            self,
            value: Optional[
                Dict[
                    str,
                    Union[HeadersModel, HeadersModel1, HeadersModel2, HeadersModel3],
                ]
            ],
            /,
        ) -> Self:
            """
            The header keys must be lowercase and use hyphen as the separator, e.g.
            """
            return self._set("headers", value)

        def ignore_uri_case(self, value: Optional[bool], /) -> Self:
            """
            Flag to specify whether the URI matching should be case-insensitive.
            """
            return self._set("ignore_uri_case", value)

        def method(
            self,
            value: Optional[Union[Method, MethodModel, MethodModel1, MethodModel2]],
            /,
        ) -> Self:
            """
            HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("method", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name assigned to a match.
            """
            return self._set("name", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Specifies the ports on the host that is being addressed.
            """
            return self._set("port", value)

        def query_params(
            self,
            value: Optional[
                Dict[
                    str,
                    Union[
                        QueryParams,
                        QueryParamsModel,
                        QueryParamsModel1,
                        QueryParamsModel2,
                    ],
                ]
            ],
            /,
        ) -> Self:
            """
            Query parameters for matching.
            """
            return self._set("query_params", value)

        def scheme(
            self,
            value: Optional[Union[Scheme, SchemeModel, SchemeModel1, SchemeModel2]],
            /,
        ) -> Self:
            """
            URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("scheme", value)

        def source_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
            """
            return self._set("source_labels", value)

        def source_namespace(self, value: Optional[str], /) -> Self:
            """
            Source namespace constraining the applicability of a rule to workloads in that namespace.
            """
            return self._set("source_namespace", value)

        def stat_prefix(self, value: Optional[str], /) -> Self:
            """
            The human readable prefix to use when emitting statistics for this route.
            """
            return self._set("stat_prefix", value)

        def uri(self, value: Optional[Union[Uri, UriModel, UriModel1, UriModel2]], /) -> Self:
            """
            URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("uri", value)

        def without_headers(
            self,
            value: Optional[
                Dict[
                    str,
                    Union[
                        WithoutHeaders,
                        WithoutHeadersModel,
                        WithoutHeadersModel1,
                        WithoutHeadersModel2,
                    ],
                ]
            ],
            /,
        ) -> Self:
            """
            withoutHeader has the same syntax with the header, but has opposite meaning.
            """
            return self._set("without_headers", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[Union[Authority, AuthorityModel, AuthorityModel1, AuthorityModel2]] = None
    """
    HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """
    gateways: Optional[List[str]] = None
    """
    Names of gateways where the rule should be applied.
    """
    headers: Optional[
        Dict[str, Union[HeadersModel, HeadersModel1, HeadersModel2, HeadersModel3]]
    ] = None
    """
    The header keys must be lowercase and use hyphen as the separator, e.g.
    """
    ignore_uri_case: Annotated[Optional[bool], Field(alias="ignoreUriCase")] = None
    """
    Flag to specify whether the URI matching should be case-insensitive.
    """
    method: Optional[Union[Method, MethodModel, MethodModel1, MethodModel2]] = None
    """
    HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """
    name: Optional[str] = None
    """
    The name assigned to a match.
    """
    port: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    Specifies the ports on the host that is being addressed.
    """
    query_params: Annotated[
        Optional[
            Dict[
                str,
                Union[QueryParams, QueryParamsModel, QueryParamsModel1, QueryParamsModel2],
            ]
        ],
        Field(alias="queryParams"),
    ] = None
    """
    Query parameters for matching.
    """
    scheme: Optional[Union[Scheme, SchemeModel, SchemeModel1, SchemeModel2]] = None
    """
    URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """
    source_labels: Annotated[Optional[Dict[str, str]], Field(alias="sourceLabels")] = None
    """
    One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
    """
    source_namespace: Annotated[Optional[str], Field(alias="sourceNamespace")] = None
    """
    Source namespace constraining the applicability of a rule to workloads in that namespace.
    """
    stat_prefix: Annotated[Optional[str], Field(alias="statPrefix")] = None
    """
    The human readable prefix to use when emitting statistics for this route.
    """
    uri: Optional[Union[Uri, UriModel, UriModel1, UriModel2]] = None
    """
    URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """
    without_headers: Annotated[
        Optional[
            Dict[
                str,
                Union[
                    WithoutHeaders,
                    WithoutHeadersModel,
                    WithoutHeadersModel1,
                    WithoutHeadersModel2,
                ],
            ]
        ],
        Field(alias="withoutHeaders"),
    ] = None
    """
    withoutHeader has the same syntax with the header, but has opposite meaning.
    """


class Mirror(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Mirror"]:
            return Mirror

        def build(self) -> "Mirror":
            return Mirror(**self._attrs)

        def host(self, value: str, /) -> Self:
            """
            The name of a service from the service registry.
            """
            return self._set("host", value)

        @overload
        def port(self, value_or_callback: Optional[PortModel3], /) -> "Mirror.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel3.Builder], PortModel3.Builder | PortModel3],
            /,
        ) -> "Mirror.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel3.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            Specifies the port on the host that is being addressed.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel3.builder())
                if isinstance(output, PortModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        def subset(self, value: Optional[str], /) -> Self:
            """
            The name of a subset within the service.
            """
            return self._set("subset", value)

    class BuilderContext(BuilderContextBase["Mirror.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Mirror.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Mirror."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Mirror", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Mirror.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: str
    """
    The name of a service from the service registry.
    """
    port: Optional[PortModel3] = None
    """
    Specifies the port on the host that is being addressed.
    """
    subset: Optional[str] = None
    """
    The name of a subset within the service.
    """


class MirrorPercentage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MirrorPercentage"]:
            return MirrorPercentage

        def build(self) -> "MirrorPercentage":
            return MirrorPercentage(**self._attrs)

        def value(self, value: Optional[float], /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["MirrorPercentage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MirrorPercentage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MirrorPercentage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MirrorPercentage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MirrorPercentage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    value: Optional[float] = None


class Destination(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Destination"]:
            return Destination

        def build(self) -> "Destination":
            return Destination(**self._attrs)

        def host(self, value: str, /) -> Self:
            """
            The name of a service from the service registry.
            """
            return self._set("host", value)

        @overload
        def port(self, value_or_callback: Optional[PortModel3], /) -> "Destination.Builder": ...

        @overload
        def port(
            self,
            value_or_callback: Callable[[PortModel3.Builder], PortModel3.Builder | PortModel3],
            /,
        ) -> "Destination.Builder": ...

        @overload
        def port(self, value_or_callback: Never = ...) -> "PortModel3.BuilderContext": ...

        def port(self, value_or_callback=None, /):
            """
            Specifies the port on the host that is being addressed.
            """
            if self._in_context and value_or_callback is None:
                context = PortModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "port"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortModel3.builder())
                if isinstance(output, PortModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("port", value)

        def subset(self, value: Optional[str], /) -> Self:
            """
            The name of a subset within the service.
            """
            return self._set("subset", value)

    class BuilderContext(BuilderContextBase["Destination.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Destination.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Destination."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Destination", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Destination.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: str
    """
    The name of a service from the service registry.
    """
    port: Optional[PortModel3] = None
    """
    Specifies the port on the host that is being addressed.
    """
    subset: Optional[str] = None
    """
    The name of a subset within the service.
    """


class MirrorModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MirrorModel"]:
            return MirrorModel

        def build(self) -> "MirrorModel":
            return MirrorModel(**self._attrs)

        @overload
        def destination(self, value_or_callback: Destination, /) -> "MirrorModel.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "MirrorModel.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            """
            Destination specifies the target of the mirror operation.
            """
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        @overload
        def percentage(
            self, value_or_callback: Optional[Percentage], /
        ) -> "MirrorModel.Builder": ...

        @overload
        def percentage(
            self,
            value_or_callback: Callable[[Percentage.Builder], Percentage.Builder | Percentage],
            /,
        ) -> "MirrorModel.Builder": ...

        @overload
        def percentage(self, value_or_callback: Never = ...) -> "Percentage.BuilderContext": ...

        def percentage(self, value_or_callback=None, /):
            """
            Percentage of the traffic to be mirrored by the `destination` field.
            """
            if self._in_context and value_or_callback is None:
                context = Percentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Percentage.builder())
                if isinstance(output, Percentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("percentage", value)

    class BuilderContext(BuilderContextBase["MirrorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MirrorModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MirrorModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MirrorModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MirrorModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination: Destination
    """
    Destination specifies the target of the mirror operation.
    """
    percentage: Optional[Percentage] = None
    """
    Percentage of the traffic to be mirrored by the `destination` field.
    """


class Redirect(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Redirect"]:
            return Redirect

        def build(self) -> "Redirect":
            return Redirect(**self._attrs)

        def authority(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Authority/Host portion of the URL with this value.
            """
            return self._set("authority", value)

        def derive_port(
            self,
            value: Optional[Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"]],
            /,
        ) -> Self:
            """
            On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

            Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
            """
            return self._set("derive_port", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            On a redirect, overwrite the port portion of the URL with this value.
            """
            return self._set("port", value)

        def redirect_code(self, value: Optional[int], /) -> Self:
            """
            On a redirect, Specifies the HTTP status code to use in the redirect response.
            """
            return self._set("redirect_code", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the scheme portion of the URL with this value.
            """
            return self._set("scheme", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Path portion of the URL with this value.
            """
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["Redirect.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Redirect.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Redirect."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Redirect", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Redirect.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[str] = None
    """
    On a redirect, overwrite the Authority/Host portion of the URL with this value.
    """
    derive_port: Annotated[
        Optional[Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"]],
        Field(alias="derivePort"),
    ] = None
    """
    On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

    Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
    """
    port: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    On a redirect, overwrite the port portion of the URL with this value.
    """
    redirect_code: Annotated[Optional[int], Field(alias="redirectCode", ge=0, le=4294967295)] = None
    """
    On a redirect, Specifies the HTTP status code to use in the redirect response.
    """
    scheme: Optional[str] = None
    """
    On a redirect, overwrite the scheme portion of the URL with this value.
    """
    uri: Optional[str] = None
    """
    On a redirect, overwrite the Path portion of the URL with this value.
    """


class RedirectModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedirectModel"]:
            return RedirectModel

        def build(self) -> "RedirectModel":
            return RedirectModel(**self._attrs)

        def authority(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Authority/Host portion of the URL with this value.
            """
            return self._set("authority", value)

        def derive_port(
            self,
            value: Optional[Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"]],
            /,
        ) -> Self:
            """
            On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

            Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
            """
            return self._set("derive_port", value)

        def port(self, value: int, /) -> Self:
            """
            On a redirect, overwrite the port portion of the URL with this value.
            """
            return self._set("port", value)

        def redirect_code(self, value: Optional[int], /) -> Self:
            """
            On a redirect, Specifies the HTTP status code to use in the redirect response.
            """
            return self._set("redirect_code", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the scheme portion of the URL with this value.
            """
            return self._set("scheme", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Path portion of the URL with this value.
            """
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["RedirectModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedirectModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedirectModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedirectModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedirectModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[str] = None
    """
    On a redirect, overwrite the Authority/Host portion of the URL with this value.
    """
    derive_port: Annotated[
        Optional[Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"]],
        Field(alias="derivePort"),
    ] = None
    """
    On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

    Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
    """
    port: Annotated[int, Field(ge=0, le=4294967295)]
    """
    On a redirect, overwrite the port portion of the URL with this value.
    """
    redirect_code: Annotated[Optional[int], Field(alias="redirectCode", ge=0, le=4294967295)] = None
    """
    On a redirect, Specifies the HTTP status code to use in the redirect response.
    """
    scheme: Optional[str] = None
    """
    On a redirect, overwrite the scheme portion of the URL with this value.
    """
    uri: Optional[str] = None
    """
    On a redirect, overwrite the Path portion of the URL with this value.
    """


class RedirectModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedirectModel1"]:
            return RedirectModel1

        def build(self) -> "RedirectModel1":
            return RedirectModel1(**self._attrs)

        def authority(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Authority/Host portion of the URL with this value.
            """
            return self._set("authority", value)

        def derive_port(
            self, value: Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"], /
        ) -> Self:
            """
            On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

            Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
            """
            return self._set("derive_port", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            On a redirect, overwrite the port portion of the URL with this value.
            """
            return self._set("port", value)

        def redirect_code(self, value: Optional[int], /) -> Self:
            """
            On a redirect, Specifies the HTTP status code to use in the redirect response.
            """
            return self._set("redirect_code", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the scheme portion of the URL with this value.
            """
            return self._set("scheme", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            On a redirect, overwrite the Path portion of the URL with this value.
            """
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["RedirectModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedirectModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedirectModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedirectModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedirectModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[str] = None
    """
    On a redirect, overwrite the Authority/Host portion of the URL with this value.
    """
    derive_port: Annotated[
        Literal["FROM_PROTOCOL_DEFAULT", "FROM_REQUEST_PORT"], Field(alias="derivePort")
    ]
    """
    On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

    Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
    """
    port: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    On a redirect, overwrite the port portion of the URL with this value.
    """
    redirect_code: Annotated[Optional[int], Field(alias="redirectCode", ge=0, le=4294967295)] = None
    """
    On a redirect, Specifies the HTTP status code to use in the redirect response.
    """
    scheme: Optional[str] = None
    """
    On a redirect, overwrite the scheme portion of the URL with this value.
    """
    uri: Optional[str] = None
    """
    On a redirect, overwrite the Path portion of the URL with this value.
    """


class Retries(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Retries"]:
            return Retries

        def build(self) -> "Retries":
            return Retries(**self._attrs)

        def attempts(self, value: Optional[int], /) -> Self:
            """
            Number of retries to be allowed for a given request.
            """
            return self._set("attempts", value)

        def per_try_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout per attempt for a given request, including the initial call and any retries.
            """
            return self._set("per_try_timeout", value)

        def retry_on(self, value: Optional[str], /) -> Self:
            """
            Specifies the conditions under which retry takes place.
            """
            return self._set("retry_on", value)

        def retry_remote_localities(self, value: Optional[bool], /) -> Self:
            """
            Flag to specify whether the retries should retry to other localities.
            """
            return self._set("retry_remote_localities", value)

    class BuilderContext(BuilderContextBase["Retries.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Retries.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Retries."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Retries", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Retries.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attempts: Optional[int] = None
    """
    Number of retries to be allowed for a given request.
    """
    per_try_timeout: Annotated[Optional[str], Field(alias="perTryTimeout")] = None
    """
    Timeout per attempt for a given request, including the initial call and any retries.
    """
    retry_on: Annotated[Optional[str], Field(alias="retryOn")] = None
    """
    Specifies the conditions under which retry takes place.
    """
    retry_remote_localities: Annotated[Optional[bool], Field(alias="retryRemoteLocalities")] = None
    """
    Flag to specify whether the retries should retry to other localities.
    """


class UriRegexRewrite(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UriRegexRewrite"]:
            return UriRegexRewrite

        def build(self) -> "UriRegexRewrite":
            return UriRegexRewrite(**self._attrs)

        def match(self, value: Optional[str], /) -> Self:
            """
            [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
            """
            return self._set("match", value)

        def rewrite(self, value: Optional[str], /) -> Self:
            """
            The string that should replace into matching portions of original URI.
            """
            return self._set("rewrite", value)

    class BuilderContext(BuilderContextBase["UriRegexRewrite.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UriRegexRewrite.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UriRegexRewrite."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UriRegexRewrite", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UriRegexRewrite.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match: Optional[str] = None
    """
    [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
    """
    rewrite: Optional[str] = None
    """
    The string that should replace into matching portions of original URI.
    """


class Rewrite(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rewrite"]:
            return Rewrite

        def build(self) -> "Rewrite":
            return Rewrite(**self._attrs)

        def authority(self, value: Optional[str], /) -> Self:
            """
            rewrite the Authority/Host header with this value.
            """
            return self._set("authority", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            rewrite the path (or the prefix) portion of the URI with this value.
            """
            return self._set("uri", value)

        @overload
        def uri_regex_rewrite(
            self, value_or_callback: Optional[UriRegexRewrite], /
        ) -> "Rewrite.Builder": ...

        @overload
        def uri_regex_rewrite(
            self,
            value_or_callback: Callable[
                [UriRegexRewrite.Builder], UriRegexRewrite.Builder | UriRegexRewrite
            ],
            /,
        ) -> "Rewrite.Builder": ...

        @overload
        def uri_regex_rewrite(
            self, value_or_callback: Never = ...
        ) -> "UriRegexRewrite.BuilderContext": ...

        def uri_regex_rewrite(self, value_or_callback=None, /):
            """
            rewrite the path portion of the URI with the specified regex.
            """
            if self._in_context and value_or_callback is None:
                context = UriRegexRewrite.BuilderContext()
                context._parent_builder = self
                context._field_name = "uri_regex_rewrite"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UriRegexRewrite.builder())
                if isinstance(output, UriRegexRewrite.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("uri_regex_rewrite", value)

    class BuilderContext(BuilderContextBase["Rewrite.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rewrite.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rewrite."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rewrite", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rewrite.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authority: Optional[str] = None
    """
    rewrite the Authority/Host header with this value.
    """
    uri: Optional[str] = None
    """
    rewrite the path (or the prefix) portion of the URI with this value.
    """
    uri_regex_rewrite: Annotated[Optional[UriRegexRewrite], Field(alias="uriRegexRewrite")] = None
    """
    rewrite the path portion of the URI with the specified regex.
    """


class HeadersModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HeadersModel4"]:
            return HeadersModel4

        def build(self) -> "HeadersModel4":
            return HeadersModel4(**self._attrs)

        @overload
        def request(self, value_or_callback: Optional[Request], /) -> "HeadersModel4.Builder": ...

        @overload
        def request(
            self,
            value_or_callback: Callable[[Request.Builder], Request.Builder | Request],
            /,
        ) -> "HeadersModel4.Builder": ...

        @overload
        def request(self, value_or_callback: Never = ...) -> "Request.BuilderContext": ...

        def request(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Request.BuilderContext()
                context._parent_builder = self
                context._field_name = "request"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Request.builder())
                if isinstance(output, Request.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request", value)

        @overload
        def response(self, value_or_callback: Optional[Response], /) -> "HeadersModel4.Builder": ...

        @overload
        def response(
            self,
            value_or_callback: Callable[[Response.Builder], Response.Builder | Response],
            /,
        ) -> "HeadersModel4.Builder": ...

        @overload
        def response(self, value_or_callback: Never = ...) -> "Response.BuilderContext": ...

        def response(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Response.BuilderContext()
                context._parent_builder = self
                context._field_name = "response"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Response.builder())
                if isinstance(output, Response.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response", value)

    class BuilderContext(BuilderContextBase["HeadersModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HeadersModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HeadersModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HeadersModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HeadersModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    request: Optional[Request] = None
    response: Optional[Response] = None


class Route(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Route"]:
            return Route

        def build(self) -> "Route":
            return Route(**self._attrs)

        @overload
        def destination(self, value_or_callback: Destination, /) -> "Route.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "Route.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            """
            Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
            """
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        @overload
        def headers(self, value_or_callback: Optional[HeadersModel4], /) -> "Route.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[
                [HeadersModel4.Builder], HeadersModel4.Builder | HeadersModel4
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> "HeadersModel4.BuilderContext": ...

        def headers(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HeadersModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HeadersModel4.builder())
                if isinstance(output, HeadersModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight specifies the relative proportion of traffic to be forwarded to the destination.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Route.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Route.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Route."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Route", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Route.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination: Destination
    """
    Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
    """
    headers: Optional[HeadersModel4] = None
    weight: Optional[int] = None
    """
    Weight specifies the relative proportion of traffic to be forwarded to the destination.
    """


class HttpModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpModel"]:
            return HttpModel

        def build(self) -> "HttpModel":
            return HttpModel(**self._attrs)

        @overload
        def cors_policy(
            self, value_or_callback: Optional[CorsPolicy], /
        ) -> "HttpModel.Builder": ...

        @overload
        def cors_policy(
            self,
            value_or_callback: Callable[[CorsPolicy.Builder], CorsPolicy.Builder | CorsPolicy],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def cors_policy(self, value_or_callback: Never = ...) -> "CorsPolicy.BuilderContext": ...

        def cors_policy(self, value_or_callback=None, /):
            """
            Cross-Origin Resource Sharing policy (CORS).
            """
            if self._in_context and value_or_callback is None:
                context = CorsPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "cors_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CorsPolicy.builder())
                if isinstance(output, CorsPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cors_policy", value)

        @overload
        def delegate(self, value_or_callback: Optional[Delegate], /) -> "HttpModel.Builder": ...

        @overload
        def delegate(
            self,
            value_or_callback: Callable[[Delegate.Builder], Delegate.Builder | Delegate],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def delegate(self, value_or_callback: Never = ...) -> "Delegate.BuilderContext": ...

        def delegate(self, value_or_callback=None, /):
            """
            Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
            """
            if self._in_context and value_or_callback is None:
                context = Delegate.BuilderContext()
                context._parent_builder = self
                context._field_name = "delegate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delegate.builder())
                if isinstance(output, Delegate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delegate", value)

        @overload
        def direct_response(
            self, value_or_callback: Optional[DirectResponse], /
        ) -> "HttpModel.Builder": ...

        @overload
        def direct_response(
            self,
            value_or_callback: Callable[
                [DirectResponse.Builder], DirectResponse.Builder | DirectResponse
            ],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def direct_response(
            self, value_or_callback: Never = ...
        ) -> "DirectResponse.BuilderContext": ...

        def direct_response(self, value_or_callback=None, /):
            """
            A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
            """
            if self._in_context and value_or_callback is None:
                context = DirectResponse.BuilderContext()
                context._parent_builder = self
                context._field_name = "direct_response"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DirectResponse.builder())
                if isinstance(output, DirectResponse.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("direct_response", value)

        @overload
        def fault(self, value_or_callback: Optional[Fault], /) -> "HttpModel.Builder": ...

        @overload
        def fault(
            self, value_or_callback: Callable[[Fault.Builder], Fault.Builder | Fault], /
        ) -> "HttpModel.Builder": ...

        @overload
        def fault(self, value_or_callback: Never = ...) -> "Fault.BuilderContext": ...

        def fault(self, value_or_callback=None, /):
            """
            Fault injection policy to apply on HTTP traffic at the client side.
            """
            if self._in_context and value_or_callback is None:
                context = Fault.BuilderContext()
                context._parent_builder = self
                context._field_name = "fault"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Fault.builder())
                if isinstance(output, Fault.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("fault", value)

        @overload
        def headers(self, value_or_callback: Optional[Headers], /) -> "HttpModel.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[[Headers.Builder], Headers.Builder | Headers],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> "Headers.BuilderContext": ...

        def headers(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Headers.BuilderContext()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Headers.builder())
                if isinstance(output, Headers.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        @overload
        def match(self, value_or_callback: List[Match], /) -> "HttpModel.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Match, Match.Builder]],
                GenericListBuilder[Match, Match.Builder] | List[Match],
            ],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> ListBuilderContext[Match.Builder]: ...

        def match(self, value_or_callback=None, /):
            """
            Match conditions to be satisfied for the rule to be activated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Match.Builder]()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def mirror(self, value_or_callback: Optional[Mirror], /) -> "HttpModel.Builder": ...

        @overload
        def mirror(
            self,
            value_or_callback: Callable[[Mirror.Builder], Mirror.Builder | Mirror],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def mirror(self, value_or_callback: Never = ...) -> "Mirror.BuilderContext": ...

        def mirror(self, value_or_callback=None, /):
            """
            Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
            """
            if self._in_context and value_or_callback is None:
                context = Mirror.BuilderContext()
                context._parent_builder = self
                context._field_name = "mirror"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mirror.builder())
                if isinstance(output, Mirror.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mirror", value)

        def mirror_percent(self, value: Optional[int], /) -> Self:
            return self._set("mirror_percent", value)

        def mirror_percent_1(self, value: Optional[int], /) -> Self:
            return self._set("mirror_percent_1", value)

        @overload
        def mirror_percentage(
            self, value_or_callback: Optional[MirrorPercentage], /
        ) -> "HttpModel.Builder": ...

        @overload
        def mirror_percentage(
            self,
            value_or_callback: Callable[
                [MirrorPercentage.Builder], MirrorPercentage.Builder | MirrorPercentage
            ],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def mirror_percentage(
            self, value_or_callback: Never = ...
        ) -> "MirrorPercentage.BuilderContext": ...

        def mirror_percentage(self, value_or_callback=None, /):
            """
            Percentage of the traffic to be mirrored by the `mirror` field.
            """
            if self._in_context and value_or_callback is None:
                context = MirrorPercentage.BuilderContext()
                context._parent_builder = self
                context._field_name = "mirror_percentage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MirrorPercentage.builder())
                if isinstance(output, MirrorPercentage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mirror_percentage", value)

        @overload
        def mirrors(self, value_or_callback: List[MirrorModel], /) -> "HttpModel.Builder": ...

        @overload
        def mirrors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MirrorModel, MirrorModel.Builder]],
                GenericListBuilder[MirrorModel, MirrorModel.Builder] | List[MirrorModel],
            ],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def mirrors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MirrorModel.Builder]: ...

        def mirrors(self, value_or_callback=None, /):
            """
            Specifies the destinations to mirror HTTP traffic in addition to the original destination.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MirrorModel.Builder]()
                context._parent_builder = self
                context._field_name = "mirrors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MirrorModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("mirrors", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name assigned to the route for debugging purposes.
            """
            return self._set("name", value)

        def redirect(
            self, value: Optional[Union[Redirect, RedirectModel, RedirectModel1]], /
        ) -> Self:
            """
            A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
            """
            return self._set("redirect", value)

        @overload
        def retries(self, value_or_callback: Optional[Retries], /) -> "HttpModel.Builder": ...

        @overload
        def retries(
            self,
            value_or_callback: Callable[[Retries.Builder], Retries.Builder | Retries],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def retries(self, value_or_callback: Never = ...) -> "Retries.BuilderContext": ...

        def retries(self, value_or_callback=None, /):
            """
            Retry policy for HTTP requests.
            """
            if self._in_context and value_or_callback is None:
                context = Retries.BuilderContext()
                context._parent_builder = self
                context._field_name = "retries"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Retries.builder())
                if isinstance(output, Retries.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("retries", value)

        @overload
        def rewrite(self, value_or_callback: Optional[Rewrite], /) -> "HttpModel.Builder": ...

        @overload
        def rewrite(
            self,
            value_or_callback: Callable[[Rewrite.Builder], Rewrite.Builder | Rewrite],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def rewrite(self, value_or_callback: Never = ...) -> "Rewrite.BuilderContext": ...

        def rewrite(self, value_or_callback=None, /):
            """
            Rewrite HTTP URIs and Authority headers.
            """
            if self._in_context and value_or_callback is None:
                context = Rewrite.BuilderContext()
                context._parent_builder = self
                context._field_name = "rewrite"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rewrite.builder())
                if isinstance(output, Rewrite.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rewrite", value)

        @overload
        def route(self, value_or_callback: List[Route], /) -> "HttpModel.Builder": ...

        @overload
        def route(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Route, Route.Builder]],
                GenericListBuilder[Route, Route.Builder] | List[Route],
            ],
            /,
        ) -> "HttpModel.Builder": ...

        @overload
        def route(self, value_or_callback: Never = ...) -> ListBuilderContext[Route.Builder]: ...

        def route(self, value_or_callback=None, /):
            """
            A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Route.Builder]()
                context._parent_builder = self
                context._field_name = "route"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("route", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for HTTP requests, default is disabled.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["HttpModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cors_policy: Annotated[Optional[CorsPolicy], Field(alias="corsPolicy")] = None
    """
    Cross-Origin Resource Sharing policy (CORS).
    """
    delegate: Optional[Delegate] = None
    """
    Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
    """
    direct_response: Annotated[Optional[DirectResponse], Field(alias="directResponse")] = None
    """
    A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
    """
    fault: Optional[Fault] = None
    """
    Fault injection policy to apply on HTTP traffic at the client side.
    """
    headers: Optional[Headers] = None
    match: Optional[List[Match]] = None
    """
    Match conditions to be satisfied for the rule to be activated.
    """
    mirror: Optional[Mirror] = None
    """
    Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
    """
    mirror_percent: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    mirror_percent_1: Annotated[
        Optional[int], Field(alias="mirrorPercent", ge=0, le=4294967295)
    ] = None
    mirror_percentage: Annotated[Optional[MirrorPercentage], Field(alias="mirrorPercentage")] = None
    """
    Percentage of the traffic to be mirrored by the `mirror` field.
    """
    mirrors: Optional[List[MirrorModel]] = None
    """
    Specifies the destinations to mirror HTTP traffic in addition to the original destination.
    """
    name: Optional[str] = None
    """
    The name assigned to the route for debugging purposes.
    """
    redirect: Optional[Union[Redirect, RedirectModel, RedirectModel1]] = None
    """
    A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
    """
    retries: Optional[Retries] = None
    """
    Retry policy for HTTP requests.
    """
    rewrite: Optional[Rewrite] = None
    """
    Rewrite HTTP URIs and Authority headers.
    """
    route: Optional[List[Route]] = None
    """
    A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
    """
    timeout: Optional[str] = None
    """
    Timeout for HTTP requests, default is disabled.
    """


class MatchModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel"]:
            return MatchModel

        def build(self) -> "MatchModel":
            return MatchModel(**self._attrs)

        def destination_subnets(self, value: Optional[List[str]], /) -> Self:
            """
            IPv4 or IPv6 ip addresses of destination with optional subnet.
            """
            return self._set("destination_subnets", value)

        def gateways(self, value: Optional[List[str]], /) -> Self:
            """
            Names of gateways where the rule should be applied.
            """
            return self._set("gateways", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Specifies the port on the host that is being addressed.
            """
            return self._set("port", value)

        def source_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that constrain the applicability of a rule to workloads with the given labels.
            """
            return self._set("source_labels", value)

        def source_namespace(self, value: Optional[str], /) -> Self:
            """
            Source namespace constraining the applicability of a rule to workloads in that namespace.
            """
            return self._set("source_namespace", value)

        def source_subnet(self, value: Optional[str], /) -> Self:
            return self._set("source_subnet", value)

    class BuilderContext(BuilderContextBase["MatchModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination_subnets: Annotated[Optional[List[str]], Field(alias="destinationSubnets")] = None
    """
    IPv4 or IPv6 ip addresses of destination with optional subnet.
    """
    gateways: Optional[List[str]] = None
    """
    Names of gateways where the rule should be applied.
    """
    port: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    Specifies the port on the host that is being addressed.
    """
    source_labels: Annotated[Optional[Dict[str, str]], Field(alias="sourceLabels")] = None
    """
    One or more labels that constrain the applicability of a rule to workloads with the given labels.
    """
    source_namespace: Annotated[Optional[str], Field(alias="sourceNamespace")] = None
    """
    Source namespace constraining the applicability of a rule to workloads in that namespace.
    """
    source_subnet: Annotated[Optional[str], Field(alias="sourceSubnet")] = None


class RouteModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RouteModel"]:
            return RouteModel

        def build(self) -> "RouteModel":
            return RouteModel(**self._attrs)

        @overload
        def destination(self, value_or_callback: Destination, /) -> "RouteModel.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "RouteModel.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            """
            Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
            """
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight specifies the relative proportion of traffic to be forwarded to the destination.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["RouteModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RouteModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RouteModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RouteModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RouteModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination: Destination
    """
    Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
    """
    weight: Optional[int] = None
    """
    Weight specifies the relative proportion of traffic to be forwarded to the destination.
    """


class TcpModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpModel"]:
            return TcpModel

        def build(self) -> "TcpModel":
            return TcpModel(**self._attrs)

        @overload
        def match(self, value_or_callback: List[MatchModel], /) -> "TcpModel.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchModel, MatchModel.Builder]],
                GenericListBuilder[MatchModel, MatchModel.Builder] | List[MatchModel],
            ],
            /,
        ) -> "TcpModel.Builder": ...

        @overload
        def match(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchModel.Builder]: ...

        def match(self, value_or_callback=None, /):
            """
            Match conditions to be satisfied for the rule to be activated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchModel.Builder]()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def route(self, value_or_callback: List[RouteModel], /) -> "TcpModel.Builder": ...

        @overload
        def route(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RouteModel, RouteModel.Builder]],
                GenericListBuilder[RouteModel, RouteModel.Builder] | List[RouteModel],
            ],
            /,
        ) -> "TcpModel.Builder": ...

        @overload
        def route(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RouteModel.Builder]: ...

        def route(self, value_or_callback=None, /):
            """
            The destination to which the connection should be forwarded to.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RouteModel.Builder]()
                context._parent_builder = self
                context._field_name = "route"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("route", value)

    class BuilderContext(BuilderContextBase["TcpModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match: Optional[List[MatchModel]] = None
    """
    Match conditions to be satisfied for the rule to be activated.
    """
    route: Optional[List[RouteModel]] = None
    """
    The destination to which the connection should be forwarded to.
    """


class MatchModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel1"]:
            return MatchModel1

        def build(self) -> "MatchModel1":
            return MatchModel1(**self._attrs)

        def destination_subnets(self, value: Optional[List[str]], /) -> Self:
            """
            IPv4 or IPv6 ip addresses of destination with optional subnet.
            """
            return self._set("destination_subnets", value)

        def gateways(self, value: Optional[List[str]], /) -> Self:
            """
            Names of gateways where the rule should be applied.
            """
            return self._set("gateways", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Specifies the port on the host that is being addressed.
            """
            return self._set("port", value)

        def sni_hosts(self, value: List[str], /) -> Self:
            """
            SNI (server name indicator) to match on.
            """
            return self._set("sni_hosts", value)

        def source_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that constrain the applicability of a rule to workloads with the given labels.
            """
            return self._set("source_labels", value)

        def source_namespace(self, value: Optional[str], /) -> Self:
            """
            Source namespace constraining the applicability of a rule to workloads in that namespace.
            """
            return self._set("source_namespace", value)

    class BuilderContext(BuilderContextBase["MatchModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    destination_subnets: Annotated[Optional[List[str]], Field(alias="destinationSubnets")] = None
    """
    IPv4 or IPv6 ip addresses of destination with optional subnet.
    """
    gateways: Optional[List[str]] = None
    """
    Names of gateways where the rule should be applied.
    """
    port: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    Specifies the port on the host that is being addressed.
    """
    sni_hosts: Annotated[List[str], Field(alias="sniHosts")]
    """
    SNI (server name indicator) to match on.
    """
    source_labels: Annotated[Optional[Dict[str, str]], Field(alias="sourceLabels")] = None
    """
    One or more labels that constrain the applicability of a rule to workloads with the given labels.
    """
    source_namespace: Annotated[Optional[str], Field(alias="sourceNamespace")] = None
    """
    Source namespace constraining the applicability of a rule to workloads in that namespace.
    """


class Tl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tl"]:
            return Tl

        def build(self) -> "Tl":
            return Tl(**self._attrs)

        @overload
        def match(self, value_or_callback: List[MatchModel1], /) -> "Tl.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchModel1, MatchModel1.Builder]],
                GenericListBuilder[MatchModel1, MatchModel1.Builder] | List[MatchModel1],
            ],
            /,
        ) -> "Tl.Builder": ...

        @overload
        def match(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchModel1.Builder]: ...

        def match(self, value_or_callback=None, /):
            """
            Match conditions to be satisfied for the rule to be activated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchModel1.Builder]()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def route(self, value_or_callback: List[RouteModel], /) -> "Tl.Builder": ...

        @overload
        def route(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RouteModel, RouteModel.Builder]],
                GenericListBuilder[RouteModel, RouteModel.Builder] | List[RouteModel],
            ],
            /,
        ) -> "Tl.Builder": ...

        @overload
        def route(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RouteModel.Builder]: ...

        def route(self, value_or_callback=None, /):
            """
            The destination to which the connection should be forwarded to.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RouteModel.Builder]()
                context._parent_builder = self
                context._field_name = "route"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("route", value)

    class BuilderContext(BuilderContextBase["Tl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match: List[MatchModel1]
    """
    Match conditions to be satisfied for the rule to be activated.
    """
    route: Optional[List[RouteModel]] = None
    """
    The destination to which the connection should be forwarded to.
    """


class VirtualServiceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VirtualServiceSpec"]:
            return VirtualServiceSpec

        def build(self) -> "VirtualServiceSpec":
            return VirtualServiceSpec(**self._attrs)

        def export_to(self, value: Optional[List[str]], /) -> Self:
            """
            A list of namespaces to which this virtual service is exported.
            """
            return self._set("export_to", value)

        def gateways(self, value: Optional[List[str]], /) -> Self:
            """
            The names of gateways and sidecars that should apply these routes.
            """
            return self._set("gateways", value)

        def hosts(self, value: Optional[List[str]], /) -> Self:
            """
            The destination hosts to which traffic is being sent.
            """
            return self._set("hosts", value)

        @overload
        def http(self, value_or_callback: List[HttpModel], /) -> "VirtualServiceSpec.Builder": ...

        @overload
        def http(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpModel, HttpModel.Builder]],
                GenericListBuilder[HttpModel, HttpModel.Builder] | List[HttpModel],
            ],
            /,
        ) -> "VirtualServiceSpec.Builder": ...

        @overload
        def http(self, value_or_callback: Never = ...) -> ListBuilderContext[HttpModel.Builder]: ...

        def http(self, value_or_callback=None, /):
            """
            An ordered list of route rules for HTTP traffic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpModel.Builder]()
                context._parent_builder = self
                context._field_name = "http"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http", value)

        @overload
        def tcp(self, value_or_callback: List[TcpModel], /) -> "VirtualServiceSpec.Builder": ...

        @overload
        def tcp(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TcpModel, TcpModel.Builder]],
                GenericListBuilder[TcpModel, TcpModel.Builder] | List[TcpModel],
            ],
            /,
        ) -> "VirtualServiceSpec.Builder": ...

        @overload
        def tcp(self, value_or_callback: Never = ...) -> ListBuilderContext[TcpModel.Builder]: ...

        def tcp(self, value_or_callback=None, /):
            """
            An ordered list of route rules for opaque TCP traffic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TcpModel.Builder]()
                context._parent_builder = self
                context._field_name = "tcp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp", value)

        @overload
        def tls(self, value_or_callback: List[Tl], /) -> "VirtualServiceSpec.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Tl, Tl.Builder]],
                GenericListBuilder[Tl, Tl.Builder] | List[Tl],
            ],
            /,
        ) -> "VirtualServiceSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> ListBuilderContext[Tl.Builder]: ...

        def tls(self, value_or_callback=None, /):
            """
            An ordered list of route rule for non-terminated TLS & HTTPS traffic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Tl.Builder]()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["VirtualServiceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VirtualServiceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VirtualServiceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VirtualServiceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VirtualServiceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    export_to: Annotated[Optional[List[str]], Field(alias="exportTo")] = None
    """
    A list of namespaces to which this virtual service is exported.
    """
    gateways: Optional[List[str]] = None
    """
    The names of gateways and sidecars that should apply these routes.
    """
    hosts: Optional[List[str]] = None
    """
    The destination hosts to which traffic is being sent.
    """
    http: Optional[List[HttpModel]] = None
    """
    An ordered list of route rules for HTTP traffic.
    """
    tcp: Optional[List[TcpModel]] = None
    """
    An ordered list of route rules for opaque TCP traffic.
    """
    tls: Optional[List[Tl]] = None
    """
    An ordered list of route rule for non-terminated TLS & HTTPS traffic.
    """


class VirtualServiceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VirtualServiceStatus"]:
            return VirtualServiceStatus

        def build(self) -> "VirtualServiceStatus":
            return VirtualServiceStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "VirtualServiceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "VirtualServiceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "VirtualServiceStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "VirtualServiceStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["VirtualServiceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VirtualServiceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VirtualServiceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VirtualServiceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VirtualServiceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class WorkloadEntrySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadEntrySpec"]:
            return WorkloadEntrySpec

        def build(self) -> "WorkloadEntrySpec":
            return WorkloadEntrySpec(**self._attrs)

        def address(self, value: Optional[str], /) -> Self:
            """
            Address associated with the network endpoint without the port.
            """
            return self._set("address", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels associated with the endpoint.
            """
            return self._set("labels", value)

        def locality(self, value: Optional[str], /) -> Self:
            """
            The locality associated with the endpoint.
            """
            return self._set("locality", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            Network enables Istio to group endpoints resident in the same L3 domain/network.
            """
            return self._set("network", value)

        def ports(self, value: Optional[Dict[str, int]], /) -> Self:
            """
            Set of ports associated with the endpoint.
            """
            return self._set("ports", value)

        def service_account(self, value: Optional[str], /) -> Self:
            """
            The service account associated with the workload if a sidecar is present in the workload.
            """
            return self._set("service_account", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            The load balancing weight associated with the endpoint.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["WorkloadEntrySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadEntrySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadEntrySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadEntrySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadEntrySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Annotated[Optional[str], Field(max_length=256)] = None
    """
    Address associated with the network endpoint without the port.
    """
    labels: Optional[Dict[str, str]] = None
    """
    One or more labels associated with the endpoint.
    """
    locality: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    The locality associated with the endpoint.
    """
    network: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    Network enables Istio to group endpoints resident in the same L3 domain/network.
    """
    ports: Optional[Dict[str, int]] = None
    """
    Set of ports associated with the endpoint.
    """
    service_account: Annotated[Optional[str], Field(alias="serviceAccount", max_length=253)] = None
    """
    The service account associated with the workload if a sidecar is present in the workload.
    """
    weight: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    The load balancing weight associated with the endpoint.
    """


class WorkloadEntryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadEntryStatus"]:
            return WorkloadEntryStatus

        def build(self) -> "WorkloadEntryStatus":
            return WorkloadEntryStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "WorkloadEntryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "WorkloadEntryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "WorkloadEntryStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "WorkloadEntryStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["WorkloadEntryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadEntryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadEntryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadEntryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadEntryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None


class Command(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Command":
            value = cast(str, self._value)
            return Command(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Command.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Command.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Command."""
        return cls.BuilderContext()


class Exec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exec"]:
            return Exec

        def build(self) -> "Exec":
            return Exec(**self._attrs)

        @overload
        def command(self, value_or_callback: List[Command], /) -> "Exec.Builder": ...

        @overload
        def command(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Command, Command.Builder]],
                GenericListBuilder[Command, Command.Builder] | List[Command],
            ],
            /,
        ) -> "Exec.Builder": ...

        @overload
        def command(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Command.Builder]: ...

        def command(self, value_or_callback=None, /):
            """
            Command to run.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Command.Builder]()
                context._parent_builder = self
                context._field_name = "command"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Command.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("command", value)

    class BuilderContext(BuilderContextBase["Exec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: List[Command]
    """
    Command to run.
    """


class HttpHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpHeader"]:
            return HttpHeader

        def build(self) -> "HttpHeader":
            return HttpHeader(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["HttpHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[Optional[str], Field(pattern="^[-_A-Za-z0-9]+$")] = None
    value: Optional[str] = None


class HttpGet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpGet"]:
            return HttpGet

        def build(self) -> "HttpGet":
            return HttpGet(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Host name to connect to, defaults to the pod IP.
            """
            return self._set("host", value)

        @overload
        def http_headers(self, value_or_callback: List[HttpHeader], /) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpHeader, HttpHeader.Builder]],
                GenericListBuilder[HttpHeader, HttpHeader.Builder] | List[HttpHeader],
            ],
            /,
        ) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HttpHeader.Builder]: ...

        def http_headers(self, value_or_callback=None, /):
            """
            Headers the proxy will pass on to make the request.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpHeader.Builder]()
                context._parent_builder = self
                context._field_name = "http_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_headers", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to access on the HTTP server.
            """
            return self._set("path", value)

        def port(self, value: int, /) -> Self:
            """
            Port on which the endpoint lives.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            return self._set("scheme", value)

    class BuilderContext(BuilderContextBase["HttpGet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpGet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpGet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpGet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpGet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Host name to connect to, defaults to the pod IP.
    """
    http_headers: Annotated[Optional[List[HttpHeader]], Field(alias="httpHeaders")] = None
    """
    Headers the proxy will pass on to make the request.
    """
    path: Optional[str] = None
    """
    Path to access on the HTTP server.
    """
    port: Annotated[int, Field(ge=0, le=4294967295)]
    """
    Port on which the endpoint lives.
    """
    scheme: Optional[str] = None


class TcpSocket(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpSocket"]:
            return TcpSocket

        def build(self) -> "TcpSocket":
            return TcpSocket(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            return self._set("host", value)

        def port(self, value: int, /) -> Self:
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["TcpSocket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpSocket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpSocket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpSocket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpSocket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    port: Annotated[int, Field(ge=0, le=4294967295)]


class Probe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Probe"]:
            return Probe

        def build(self) -> "Probe":
            return Probe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "Probe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "Probe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Health is determined by how the command that is executed exited.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            """
            return self._set("failure_threshold", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "Probe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "Probe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            `httpGet` is performed to a given endpoint and the status/able to connect determines health.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before readiness probes are initiated.
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "Probe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "Probe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Health is determined by if the proxy is able to connect.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["Probe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Probe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Probe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Probe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Probe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Health is determined by how the command that is executed exited.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold", ge=0)] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    `httpGet` is performed to a given endpoint and the status/able to connect determines health.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds", ge=0)] = None
    """
    Number of seconds after the container has started before readiness probes are initiated.
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds", ge=0)] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold", ge=0)] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Health is determined by if the proxy is able to connect.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds", ge=0)] = None
    """
    Number of seconds after which the probe times out.
    """


class ProbeModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeModel"]:
            return ProbeModel

        def build(self) -> "ProbeModel":
            return ProbeModel(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "ProbeModel.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ProbeModel.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Health is determined by how the command that is executed exited.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            """
            return self._set("failure_threshold", value)

        @overload
        def http_get(self, value_or_callback: HttpGet, /) -> "ProbeModel.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ProbeModel.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            `httpGet` is performed to a given endpoint and the status/able to connect determines health.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before readiness probes are initiated.
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "ProbeModel.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ProbeModel.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Health is determined by if the proxy is able to connect.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ProbeModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Health is determined by how the command that is executed exited.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold", ge=0)] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    """
    http_get: Annotated[HttpGet, Field(alias="httpGet")]
    """
    `httpGet` is performed to a given endpoint and the status/able to connect determines health.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds", ge=0)] = None
    """
    Number of seconds after the container has started before readiness probes are initiated.
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds", ge=0)] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold", ge=0)] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Health is determined by if the proxy is able to connect.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds", ge=0)] = None
    """
    Number of seconds after which the probe times out.
    """


class ProbeModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeModel1"]:
            return ProbeModel1

        def build(self) -> "ProbeModel1":
            return ProbeModel1(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "ProbeModel1.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ProbeModel1.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Health is determined by how the command that is executed exited.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            """
            return self._set("failure_threshold", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "ProbeModel1.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ProbeModel1.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            `httpGet` is performed to a given endpoint and the status/able to connect determines health.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before readiness probes are initiated.
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(self, value_or_callback: TcpSocket, /) -> "ProbeModel1.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ProbeModel1.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Health is determined by if the proxy is able to connect.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ProbeModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Health is determined by how the command that is executed exited.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold", ge=0)] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    `httpGet` is performed to a given endpoint and the status/able to connect determines health.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds", ge=0)] = None
    """
    Number of seconds after the container has started before readiness probes are initiated.
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds", ge=0)] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold", ge=0)] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    """
    tcp_socket: Annotated[TcpSocket, Field(alias="tcpSocket")]
    """
    Health is determined by if the proxy is able to connect.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds", ge=0)] = None
    """
    Number of seconds after which the probe times out.
    """


class ProbeModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeModel2"]:
            return ProbeModel2

        def build(self) -> "ProbeModel2":
            return ProbeModel2(**self._attrs)

        @overload
        def exec(self, value_or_callback: Exec, /) -> "ProbeModel2.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ProbeModel2.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Health is determined by how the command that is executed exited.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            """
            return self._set("failure_threshold", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "ProbeModel2.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ProbeModel2.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            `httpGet` is performed to a given endpoint and the status/able to connect determines health.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before readiness probes are initiated.
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "ProbeModel2.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ProbeModel2.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Health is determined by if the proxy is able to connect.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ProbeModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Exec
    """
    Health is determined by how the command that is executed exited.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold", ge=0)] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    `httpGet` is performed to a given endpoint and the status/able to connect determines health.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds", ge=0)] = None
    """
    Number of seconds after the container has started before readiness probes are initiated.
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds", ge=0)] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold", ge=0)] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Health is determined by if the proxy is able to connect.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds", ge=0)] = None
    """
    Number of seconds after which the probe times out.
    """


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        def address(self, value: Optional[str], /) -> Self:
            """
            Address associated with the network endpoint without the port.
            """
            return self._set("address", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels associated with the endpoint.
            """
            return self._set("labels", value)

        def locality(self, value: Optional[str], /) -> Self:
            """
            The locality associated with the endpoint.
            """
            return self._set("locality", value)

        def network(self, value: Optional[str], /) -> Self:
            """
            Network enables Istio to group endpoints resident in the same L3 domain/network.
            """
            return self._set("network", value)

        def ports(self, value: Optional[Dict[str, int]], /) -> Self:
            """
            Set of ports associated with the endpoint.
            """
            return self._set("ports", value)

        def service_account(self, value: Optional[str], /) -> Self:
            """
            The service account associated with the workload if a sidecar is present in the workload.
            """
            return self._set("service_account", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            The load balancing weight associated with the endpoint.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Annotated[Optional[str], Field(max_length=256)] = None
    """
    Address associated with the network endpoint without the port.
    """
    labels: Optional[Dict[str, str]] = None
    """
    One or more labels associated with the endpoint.
    """
    locality: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    The locality associated with the endpoint.
    """
    network: Annotated[Optional[str], Field(max_length=2048)] = None
    """
    Network enables Istio to group endpoints resident in the same L3 domain/network.
    """
    ports: Optional[Dict[str, int]] = None
    """
    Set of ports associated with the endpoint.
    """
    service_account: Annotated[Optional[str], Field(alias="serviceAccount", max_length=253)] = None
    """
    The service account associated with the workload if a sidecar is present in the workload.
    """
    weight: Annotated[Optional[int], Field(ge=0, le=4294967295)] = None
    """
    The load balancing weight associated with the endpoint.
    """


class WorkloadGroupSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadGroupSpec"]:
            return WorkloadGroupSpec

        def build(self) -> "WorkloadGroupSpec":
            return WorkloadGroupSpec(**self._attrs)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "WorkloadGroupSpec.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "WorkloadGroupSpec.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata that will be used for all corresponding `WorkloadEntries`.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def probe(
            self, value: Optional[Union[Probe, ProbeModel, ProbeModel1, ProbeModel2]], /
        ) -> Self:
            """
            `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
            """
            return self._set("probe", value)

        @overload
        def template(self, value_or_callback: Template, /) -> "WorkloadGroupSpec.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "WorkloadGroupSpec.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["WorkloadGroupSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadGroupSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadGroupSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadGroupSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadGroupSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Metadata] = None
    """
    Metadata that will be used for all corresponding `WorkloadEntries`.
    """
    probe: Optional[Union[Probe, ProbeModel, ProbeModel1, ProbeModel2]] = None
    """
    `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
    """
    template: Template
    """
    Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
    """


class WorkloadGroupStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadGroupStatus"]:
            return WorkloadGroupStatus

        def build(self) -> "WorkloadGroupStatus":
            return WorkloadGroupStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "WorkloadGroupStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "WorkloadGroupStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "WorkloadGroupStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "WorkloadGroupStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["WorkloadGroupStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadGroupStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadGroupStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadGroupStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadGroupStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class DestinationRule(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DestinationRule"]:
            return DestinationRule

        def build(self) -> "DestinationRule":
            return DestinationRule(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[DestinationRuleSpec], /
        ) -> "DestinationRule.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DestinationRuleSpec.Builder],
                DestinationRuleSpec.Builder | DestinationRuleSpec,
            ],
            /,
        ) -> "DestinationRule.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DestinationRuleSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DestinationRuleSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DestinationRuleSpec.builder())
                if isinstance(output, DestinationRuleSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DestinationRuleStatus], /
        ) -> "DestinationRule.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DestinationRuleStatus.Builder],
                DestinationRuleStatus.Builder | DestinationRuleStatus,
            ],
            /,
        ) -> "DestinationRule.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "DestinationRuleStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DestinationRuleStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DestinationRuleStatus.builder())
                if isinstance(output, DestinationRuleStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DestinationRule"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DestinationRule.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DestinationRule.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["DestinationRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DestinationRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DestinationRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DestinationRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DestinationRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[DestinationRuleSpec] = None
    status: Optional[DestinationRuleStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["DestinationRule"]] = "DestinationRule"
    metadata: Optional[apimachinery.ObjectMeta] = None


class Gateway(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Gateway"]:
            return Gateway

        def build(self) -> "Gateway":
            return Gateway(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[GatewaySpec], /) -> "Gateway.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[GatewaySpec.Builder], GatewaySpec.Builder | GatewaySpec],
            /,
        ) -> "Gateway.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "GatewaySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GatewaySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GatewaySpec.builder())
                if isinstance(output, GatewaySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[GatewayStatus], /) -> "Gateway.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [GatewayStatus.Builder], GatewayStatus.Builder | GatewayStatus
            ],
            /,
        ) -> "Gateway.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "GatewayStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GatewayStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GatewayStatus.builder())
                if isinstance(output, GatewayStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Gateway"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Gateway.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Gateway.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Gateway.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Gateway.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Gateway."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Gateway", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Gateway.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[GatewaySpec] = None
    status: Optional[GatewayStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["Gateway"]] = "Gateway"
    metadata: Optional[apimachinery.ObjectMeta] = None


class ServiceEntry(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceEntry"]:
            return ServiceEntry

        def build(self) -> "ServiceEntry":
            return ServiceEntry(**self._attrs)

        @overload
        def spec(self, value_or_callback: ServiceEntrySpec, /) -> "ServiceEntry.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServiceEntrySpec.Builder], ServiceEntrySpec.Builder | ServiceEntrySpec
            ],
            /,
        ) -> "ServiceEntry.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ServiceEntrySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceEntrySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceEntrySpec.builder())
                if isinstance(output, ServiceEntrySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ServiceEntryStatus], /
        ) -> "ServiceEntry.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ServiceEntryStatus.Builder],
                ServiceEntryStatus.Builder | ServiceEntryStatus,
            ],
            /,
        ) -> "ServiceEntry.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ServiceEntryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceEntryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceEntryStatus.builder())
                if isinstance(output, ServiceEntryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServiceEntry"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ServiceEntry.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ServiceEntry.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["ServiceEntry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceEntry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceEntry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceEntry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceEntry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: ServiceEntrySpec
    status: Optional[ServiceEntryStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["ServiceEntry"]] = "ServiceEntry"
    metadata: Optional[apimachinery.ObjectMeta] = None


class Sidecar(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sidecar"]:
            return Sidecar

        def build(self) -> "Sidecar":
            return Sidecar(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[SidecarSpec], /) -> "Sidecar.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[SidecarSpec.Builder], SidecarSpec.Builder | SidecarSpec],
            /,
        ) -> "Sidecar.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SidecarSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SidecarSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SidecarSpec.builder())
                if isinstance(output, SidecarSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[SidecarStatus], /) -> "Sidecar.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SidecarStatus.Builder], SidecarStatus.Builder | SidecarStatus
            ],
            /,
        ) -> "Sidecar.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "SidecarStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SidecarStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SidecarStatus.builder())
                if isinstance(output, SidecarStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Sidecar"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Sidecar.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Sidecar.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Sidecar.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sidecar.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sidecar."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sidecar", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sidecar.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[SidecarSpec] = None
    status: Optional[SidecarStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["Sidecar"]] = "Sidecar"
    metadata: Optional[apimachinery.ObjectMeta] = None


class VirtualService(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VirtualService"]:
            return VirtualService

        def build(self) -> "VirtualService":
            return VirtualService(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[VirtualServiceSpec], /
        ) -> "VirtualService.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [VirtualServiceSpec.Builder],
                VirtualServiceSpec.Builder | VirtualServiceSpec,
            ],
            /,
        ) -> "VirtualService.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "VirtualServiceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = VirtualServiceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VirtualServiceSpec.builder())
                if isinstance(output, VirtualServiceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[VirtualServiceStatus], /
        ) -> "VirtualService.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [VirtualServiceStatus.Builder],
                VirtualServiceStatus.Builder | VirtualServiceStatus,
            ],
            /,
        ) -> "VirtualService.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "VirtualServiceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = VirtualServiceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VirtualServiceStatus.builder())
                if isinstance(output, VirtualServiceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["VirtualService"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "VirtualService.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "VirtualService.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["VirtualService.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VirtualService.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VirtualService."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VirtualService", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VirtualService.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[VirtualServiceSpec] = None
    status: Optional[VirtualServiceStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["VirtualService"]] = "VirtualService"
    metadata: Optional[apimachinery.ObjectMeta] = None


class WorkloadEntry(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadEntry"]:
            return WorkloadEntry

        def build(self) -> "WorkloadEntry":
            return WorkloadEntry(**self._attrs)

        @overload
        def spec(self, value_or_callback: WorkloadEntrySpec, /) -> "WorkloadEntry.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [WorkloadEntrySpec.Builder],
                WorkloadEntrySpec.Builder | WorkloadEntrySpec,
            ],
            /,
        ) -> "WorkloadEntry.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "WorkloadEntrySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WorkloadEntrySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadEntrySpec.builder())
                if isinstance(output, WorkloadEntrySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[WorkloadEntryStatus], /
        ) -> "WorkloadEntry.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [WorkloadEntryStatus.Builder],
                WorkloadEntryStatus.Builder | WorkloadEntryStatus,
            ],
            /,
        ) -> "WorkloadEntry.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "WorkloadEntryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WorkloadEntryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadEntryStatus.builder())
                if isinstance(output, WorkloadEntryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["WorkloadEntry"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "WorkloadEntry.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "WorkloadEntry.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["WorkloadEntry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadEntry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadEntry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadEntry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadEntry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: WorkloadEntrySpec
    status: Optional[WorkloadEntryStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["WorkloadEntry"]] = "WorkloadEntry"
    metadata: Optional[apimachinery.ObjectMeta] = None


class WorkloadGroup(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WorkloadGroup"]:
            return WorkloadGroup

        def build(self) -> "WorkloadGroup":
            return WorkloadGroup(**self._attrs)

        @overload
        def spec(self, value_or_callback: WorkloadGroupSpec, /) -> "WorkloadGroup.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [WorkloadGroupSpec.Builder],
                WorkloadGroupSpec.Builder | WorkloadGroupSpec,
            ],
            /,
        ) -> "WorkloadGroup.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "WorkloadGroupSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WorkloadGroupSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadGroupSpec.builder())
                if isinstance(output, WorkloadGroupSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[WorkloadGroupStatus], /
        ) -> "WorkloadGroup.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [WorkloadGroupStatus.Builder],
                WorkloadGroupStatus.Builder | WorkloadGroupStatus,
            ],
            /,
        ) -> "WorkloadGroup.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "WorkloadGroupStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = WorkloadGroupStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WorkloadGroupStatus.builder())
                if isinstance(output, WorkloadGroupStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["networking.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["WorkloadGroup"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "WorkloadGroup.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "WorkloadGroup.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["WorkloadGroup.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WorkloadGroup.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WorkloadGroup."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WorkloadGroup", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WorkloadGroup.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: WorkloadGroupSpec
    status: Optional[WorkloadGroupStatus] = None
    api_version: Annotated[
        Optional[Literal["networking.istio.io/v1"]], Field(alias="apiVersion")
    ] = "networking.istio.io/v1"
    kind: Optional[Literal["WorkloadGroup"]] = "WorkloadGroup"
    metadata: Optional[apimachinery.ObjectMeta] = None
