# Generated by cloudcoil-model-codegen v0.4.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        def expression(self, value: Optional[str], /) -> Self:
            """
            CEL expression for selecting when requests/connections should be logged.
            """
            return self._set("expression", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: Optional[str] = None
    """
    CEL expression for selecting when requests/connections should be logged.
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        def mode(
            self, value: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]], /
        ) -> Self:
            """
            This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.

            Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]] = None
    """
    This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.

    Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
    """


class Provider(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Provider"]:
            return Provider

        def build(self) -> "Provider":
            return Provider(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Required.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Provider.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Provider.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Provider."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Provider", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Provider.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    Required.
    """


class AccessLogging(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessLogging"]:
            return AccessLogging

        def build(self) -> "AccessLogging":
            return AccessLogging(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Controls logging.
            """
            return self._set("disabled", value)

        @overload
        def filter(self, value_or_callback: Optional[Filter], /) -> "AccessLogging.Builder": ...

        @overload
        def filter(
            self,
            value_or_callback: Callable[[Filter.Builder], Filter.Builder | Filter],
            /,
        ) -> "AccessLogging.Builder": ...

        @overload
        def filter(self, value_or_callback: Never = ...) -> "Filter.BuilderContext": ...

        def filter(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = Filter.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.builder())
                if isinstance(output, Filter.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "AccessLogging.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "AccessLogging.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Allows tailoring of logging behavior to specific conditions.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def providers(self, value_or_callback: List[Provider], /) -> "AccessLogging.Builder": ...

        @overload
        def providers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Provider, Provider.Builder]],
                GenericListBuilder[Provider, Provider.Builder] | List[Provider],
            ],
            /,
        ) -> "AccessLogging.Builder": ...

        @overload
        def providers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Provider.Builder]: ...

        def providers(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Provider.Builder]()
                context._parent_builder = self
                context._field_name = "providers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Provider.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("providers", value)

    class BuilderContext(BuilderContextBase["AccessLogging.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessLogging.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessLogging."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessLogging", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessLogging.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Controls logging.
    """
    filter: Optional[Filter] = None
    """
    Optional.
    """
    match: Optional[Match] = None
    """
    Allows tailoring of logging behavior to specific conditions.
    """
    providers: Optional[List[Provider]] = None
    """
    Optional.
    """


class MatchModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel"]:
            return MatchModel

        def build(self) -> "MatchModel":
            return MatchModel(**self._attrs)

        def custom_metric(self, value: Optional[str], /) -> Self:
            """
            Allows free-form specification of a metric.
            """
            return self._set("custom_metric", value)

        def metric(
            self,
            value: Optional[
                Literal[
                    "ALL_METRICS",
                    "REQUEST_COUNT",
                    "REQUEST_DURATION",
                    "REQUEST_SIZE",
                    "RESPONSE_SIZE",
                    "TCP_OPENED_CONNECTIONS",
                    "TCP_CLOSED_CONNECTIONS",
                    "TCP_SENT_BYTES",
                    "TCP_RECEIVED_BYTES",
                    "GRPC_REQUEST_MESSAGES",
                    "GRPC_RESPONSE_MESSAGES",
                ]
            ],
            /,
        ) -> Self:
            """
            One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

            Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
            """
            return self._set("metric", value)

        def mode(
            self, value: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]], /
        ) -> Self:
            """
            Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

            Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["MatchModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    custom_metric: Annotated[Optional[str], Field(alias="customMetric", min_length=1)] = None
    """
    Allows free-form specification of a metric.
    """
    metric: Optional[
        Literal[
            "ALL_METRICS",
            "REQUEST_COUNT",
            "REQUEST_DURATION",
            "REQUEST_SIZE",
            "RESPONSE_SIZE",
            "TCP_OPENED_CONNECTIONS",
            "TCP_CLOSED_CONNECTIONS",
            "TCP_SENT_BYTES",
            "TCP_RECEIVED_BYTES",
            "GRPC_REQUEST_MESSAGES",
            "GRPC_RESPONSE_MESSAGES",
        ]
    ] = None
    """
    One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

    Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
    """
    mode: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]] = None
    """
    Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

    Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
    """


class MatchModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel1"]:
            return MatchModel1

        def build(self) -> "MatchModel1":
            return MatchModel1(**self._attrs)

        def custom_metric(self, value: Optional[str], /) -> Self:
            """
            Allows free-form specification of a metric.
            """
            return self._set("custom_metric", value)

        def metric(
            self,
            value: Literal[
                "ALL_METRICS",
                "REQUEST_COUNT",
                "REQUEST_DURATION",
                "REQUEST_SIZE",
                "RESPONSE_SIZE",
                "TCP_OPENED_CONNECTIONS",
                "TCP_CLOSED_CONNECTIONS",
                "TCP_SENT_BYTES",
                "TCP_RECEIVED_BYTES",
                "GRPC_REQUEST_MESSAGES",
                "GRPC_RESPONSE_MESSAGES",
            ],
            /,
        ) -> Self:
            """
            One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

            Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
            """
            return self._set("metric", value)

        def mode(
            self, value: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]], /
        ) -> Self:
            """
            Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

            Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["MatchModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    custom_metric: Annotated[Optional[str], Field(alias="customMetric", min_length=1)] = None
    """
    Allows free-form specification of a metric.
    """
    metric: Literal[
        "ALL_METRICS",
        "REQUEST_COUNT",
        "REQUEST_DURATION",
        "REQUEST_SIZE",
        "RESPONSE_SIZE",
        "TCP_OPENED_CONNECTIONS",
        "TCP_CLOSED_CONNECTIONS",
        "TCP_SENT_BYTES",
        "TCP_RECEIVED_BYTES",
        "GRPC_REQUEST_MESSAGES",
        "GRPC_RESPONSE_MESSAGES",
    ]
    """
    One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

    Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
    """
    mode: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]] = None
    """
    Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

    Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
    """


class MatchModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel2"]:
            return MatchModel2

        def build(self) -> "MatchModel2":
            return MatchModel2(**self._attrs)

        def custom_metric(self, value: str, /) -> Self:
            """
            Allows free-form specification of a metric.
            """
            return self._set("custom_metric", value)

        def metric(
            self,
            value: Optional[
                Literal[
                    "ALL_METRICS",
                    "REQUEST_COUNT",
                    "REQUEST_DURATION",
                    "REQUEST_SIZE",
                    "RESPONSE_SIZE",
                    "TCP_OPENED_CONNECTIONS",
                    "TCP_CLOSED_CONNECTIONS",
                    "TCP_SENT_BYTES",
                    "TCP_RECEIVED_BYTES",
                    "GRPC_REQUEST_MESSAGES",
                    "GRPC_RESPONSE_MESSAGES",
                ]
            ],
            /,
        ) -> Self:
            """
            One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

            Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
            """
            return self._set("metric", value)

        def mode(
            self, value: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]], /
        ) -> Self:
            """
            Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

            Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["MatchModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    custom_metric: Annotated[str, Field(alias="customMetric", min_length=1)]
    """
    Allows free-form specification of a metric.
    """
    metric: Optional[
        Literal[
            "ALL_METRICS",
            "REQUEST_COUNT",
            "REQUEST_DURATION",
            "REQUEST_SIZE",
            "RESPONSE_SIZE",
            "TCP_OPENED_CONNECTIONS",
            "TCP_CLOSED_CONNECTIONS",
            "TCP_SENT_BYTES",
            "TCP_RECEIVED_BYTES",
            "GRPC_REQUEST_MESSAGES",
            "GRPC_RESPONSE_MESSAGES",
        ]
    ] = None
    """
    One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).

    Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
    """
    mode: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]] = None
    """
    Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.

    Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
    """


class TagOverrides(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TagOverrides"]:
            return TagOverrides

        def build(self) -> "TagOverrides":
            return TagOverrides(**self._attrs)

        def operation(self, value: Optional[Literal["UPSERT", "REMOVE"]], /) -> Self:
            """
            Operation controls whether or not to update/add a tag, or to remove it.

            Valid Options: UPSERT, REMOVE
            """
            return self._set("operation", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is only considered if the operation is `UPSERT`.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["TagOverrides.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TagOverrides.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TagOverrides."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TagOverrides", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TagOverrides.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    operation: Optional[Literal["UPSERT", "REMOVE"]] = None
    """
    Operation controls whether or not to update/add a tag, or to remove it.

    Valid Options: UPSERT, REMOVE
    """
    value: Optional[str] = None
    """
    Value is only considered if the operation is `UPSERT`.
    """


class Override(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Override"]:
            return Override

        def build(self) -> "Override":
            return Override(**self._attrs)

        def disabled(self, value: Optional[bool], /) -> Self:
            """
            Optional.
            """
            return self._set("disabled", value)

        def match(self, value: Optional[Union[MatchModel, MatchModel1, MatchModel2]], /) -> Self:
            """
            Match allows providing the scope of the override.
            """
            return self._set("match", value)

        def tag_overrides(self, value: Optional[Dict[str, TagOverrides]], /) -> Self:
            """
            Optional.
            """
            return self._set("tag_overrides", value)

    class BuilderContext(BuilderContextBase["Override.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Override.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Override."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Override", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Override.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disabled: Optional[bool] = None
    """
    Optional.
    """
    match: Optional[Union[MatchModel, MatchModel1, MatchModel2]] = None
    """
    Match allows providing the scope of the override.
    """
    tag_overrides: Annotated[Optional[Dict[str, TagOverrides]], Field(alias="tagOverrides")] = None
    """
    Optional.
    """


class Metric(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metric"]:
            return Metric

        def build(self) -> "Metric":
            return Metric(**self._attrs)

        @overload
        def overrides(self, value_or_callback: List[Override], /) -> "Metric.Builder": ...

        @overload
        def overrides(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Override, Override.Builder]],
                GenericListBuilder[Override, Override.Builder] | List[Override],
            ],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def overrides(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Override.Builder]: ...

        def overrides(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Override.Builder]()
                context._parent_builder = self
                context._field_name = "overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Override.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("overrides", value)

        @overload
        def providers(self, value_or_callback: List[Provider], /) -> "Metric.Builder": ...

        @overload
        def providers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Provider, Provider.Builder]],
                GenericListBuilder[Provider, Provider.Builder] | List[Provider],
            ],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def providers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Provider.Builder]: ...

        def providers(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Provider.Builder]()
                context._parent_builder = self
                context._field_name = "providers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Provider.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("providers", value)

        def reporting_interval(self, value: Optional[str], /) -> Self:
            """
            Optional.
            """
            return self._set("reporting_interval", value)

    class BuilderContext(BuilderContextBase["Metric.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metric.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metric."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metric", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metric.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    overrides: Optional[List[Override]] = None
    """
    Optional.
    """
    providers: Optional[List[Provider]] = None
    """
    Optional.
    """
    reporting_interval: Annotated[Optional[str], Field(alias="reportingInterval")] = None
    """
    Optional.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
    """


class TargetRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TargetRef"]:
            return TargetRef

        def build(self) -> "TargetRef":
            return TargetRef(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            """
            group is the group of the target resource.
            """
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            """
            kind is kind of the target resource.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            name is the name of the target resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            namespace is the namespace of the referent.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["TargetRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TargetRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TargetRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TargetRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TargetRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Annotated[
        Optional[str],
        Field(
            max_length=253,
            pattern="^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
        ),
    ] = None
    """
    group is the group of the target resource.
    """
    kind: Annotated[
        str,
        Field(max_length=63, min_length=1, pattern="^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"),
    ]
    """
    kind is kind of the target resource.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    name is the name of the target resource.
    """
    namespace: Optional[str] = None
    """
    namespace is the namespace of the referent.
    """


class Environment(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Environment"]:
            return Environment

        def build(self) -> "Environment":
            return Environment(**self._attrs)

        def default_value(self, value: Optional[str], /) -> Self:
            """
            Optional.
            """
            return self._set("default_value", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the environment variable from which to extract the tag value.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Environment.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Environment.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Environment."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Environment", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Environment.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_value: Annotated[Optional[str], Field(alias="defaultValue")] = None
    """
    Optional.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the environment variable from which to extract the tag value.
    """


class Header(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Header"]:
            return Header

        def build(self) -> "Header":
            return Header(**self._attrs)

        def default_value(self, value: Optional[str], /) -> Self:
            """
            Optional.
            """
            return self._set("default_value", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the header from which to extract the tag value.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Header.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Header.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Header."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Header", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Header.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_value: Annotated[Optional[str], Field(alias="defaultValue")] = None
    """
    Optional.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the header from which to extract the tag value.
    """


class LiteralModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LiteralModel"]:
            return LiteralModel

        def build(self) -> "LiteralModel":
            return LiteralModel(**self._attrs)

        def value(self, value: str, /) -> Self:
            """
            The tag value to use.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["LiteralModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LiteralModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LiteralModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LiteralModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LiteralModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    value: Annotated[str, Field(min_length=1)]
    """
    The tag value to use.
    """


class CustomTags(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomTags"]:
            return CustomTags

        def build(self) -> "CustomTags":
            return CustomTags(**self._attrs)

        @overload
        def environment(
            self, value_or_callback: Optional[Environment], /
        ) -> "CustomTags.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "CustomTags.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment adds the value of an environment variable to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        @overload
        def header(self, value_or_callback: Optional[Header], /) -> "CustomTags.Builder": ...

        @overload
        def header(
            self,
            value_or_callback: Callable[[Header.Builder], Header.Builder | Header],
            /,
        ) -> "CustomTags.Builder": ...

        @overload
        def header(self, value_or_callback: Never = ...) -> "Header.BuilderContext": ...

        def header(self, value_or_callback=None, /):
            """
            RequestHeader adds the value of an header from the request to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Header.BuilderContext()
                context._parent_builder = self
                context._field_name = "header"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Header.builder())
                if isinstance(output, Header.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("header", value)

        @overload
        def literal(self, value_or_callback: Optional[LiteralModel], /) -> "CustomTags.Builder": ...

        @overload
        def literal(
            self,
            value_or_callback: Callable[
                [LiteralModel.Builder], LiteralModel.Builder | LiteralModel
            ],
            /,
        ) -> "CustomTags.Builder": ...

        @overload
        def literal(self, value_or_callback: Never = ...) -> "LiteralModel.BuilderContext": ...

        def literal(self, value_or_callback=None, /):
            """
            Literal adds the same, hard-coded value to each span.
            """
            if self._in_context and value_or_callback is None:
                context = LiteralModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "literal"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LiteralModel.builder())
                if isinstance(output, LiteralModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("literal", value)

    class BuilderContext(BuilderContextBase["CustomTags.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomTags.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomTags."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomTags", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomTags.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment: Optional[Environment] = None
    """
    Environment adds the value of an environment variable to each span.
    """
    header: Optional[Header] = None
    """
    RequestHeader adds the value of an header from the request to each span.
    """
    literal: Optional[LiteralModel] = None
    """
    Literal adds the same, hard-coded value to each span.
    """


class CustomTagsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomTagsModel"]:
            return CustomTagsModel

        def build(self) -> "CustomTagsModel":
            return CustomTagsModel(**self._attrs)

        @overload
        def environment(
            self, value_or_callback: Optional[Environment], /
        ) -> "CustomTagsModel.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "CustomTagsModel.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment adds the value of an environment variable to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        @overload
        def header(self, value_or_callback: Optional[Header], /) -> "CustomTagsModel.Builder": ...

        @overload
        def header(
            self,
            value_or_callback: Callable[[Header.Builder], Header.Builder | Header],
            /,
        ) -> "CustomTagsModel.Builder": ...

        @overload
        def header(self, value_or_callback: Never = ...) -> "Header.BuilderContext": ...

        def header(self, value_or_callback=None, /):
            """
            RequestHeader adds the value of an header from the request to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Header.BuilderContext()
                context._parent_builder = self
                context._field_name = "header"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Header.builder())
                if isinstance(output, Header.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("header", value)

        @overload
        def literal(self, value_or_callback: LiteralModel, /) -> "CustomTagsModel.Builder": ...

        @overload
        def literal(
            self,
            value_or_callback: Callable[
                [LiteralModel.Builder], LiteralModel.Builder | LiteralModel
            ],
            /,
        ) -> "CustomTagsModel.Builder": ...

        @overload
        def literal(self, value_or_callback: Never = ...) -> "LiteralModel.BuilderContext": ...

        def literal(self, value_or_callback=None, /):
            """
            Literal adds the same, hard-coded value to each span.
            """
            if self._in_context and value_or_callback is None:
                context = LiteralModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "literal"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LiteralModel.builder())
                if isinstance(output, LiteralModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("literal", value)

    class BuilderContext(BuilderContextBase["CustomTagsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomTagsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomTagsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomTagsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomTagsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment: Optional[Environment] = None
    """
    Environment adds the value of an environment variable to each span.
    """
    header: Optional[Header] = None
    """
    RequestHeader adds the value of an header from the request to each span.
    """
    literal: LiteralModel
    """
    Literal adds the same, hard-coded value to each span.
    """


class CustomTagsModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomTagsModel1"]:
            return CustomTagsModel1

        def build(self) -> "CustomTagsModel1":
            return CustomTagsModel1(**self._attrs)

        @overload
        def environment(self, value_or_callback: Environment, /) -> "CustomTagsModel1.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "CustomTagsModel1.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment adds the value of an environment variable to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        @overload
        def header(self, value_or_callback: Optional[Header], /) -> "CustomTagsModel1.Builder": ...

        @overload
        def header(
            self,
            value_or_callback: Callable[[Header.Builder], Header.Builder | Header],
            /,
        ) -> "CustomTagsModel1.Builder": ...

        @overload
        def header(self, value_or_callback: Never = ...) -> "Header.BuilderContext": ...

        def header(self, value_or_callback=None, /):
            """
            RequestHeader adds the value of an header from the request to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Header.BuilderContext()
                context._parent_builder = self
                context._field_name = "header"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Header.builder())
                if isinstance(output, Header.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("header", value)

        @overload
        def literal(
            self, value_or_callback: Optional[LiteralModel], /
        ) -> "CustomTagsModel1.Builder": ...

        @overload
        def literal(
            self,
            value_or_callback: Callable[
                [LiteralModel.Builder], LiteralModel.Builder | LiteralModel
            ],
            /,
        ) -> "CustomTagsModel1.Builder": ...

        @overload
        def literal(self, value_or_callback: Never = ...) -> "LiteralModel.BuilderContext": ...

        def literal(self, value_or_callback=None, /):
            """
            Literal adds the same, hard-coded value to each span.
            """
            if self._in_context and value_or_callback is None:
                context = LiteralModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "literal"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LiteralModel.builder())
                if isinstance(output, LiteralModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("literal", value)

    class BuilderContext(BuilderContextBase["CustomTagsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomTagsModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomTagsModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomTagsModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomTagsModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment: Environment
    """
    Environment adds the value of an environment variable to each span.
    """
    header: Optional[Header] = None
    """
    RequestHeader adds the value of an header from the request to each span.
    """
    literal: Optional[LiteralModel] = None
    """
    Literal adds the same, hard-coded value to each span.
    """


class CustomTagsModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomTagsModel2"]:
            return CustomTagsModel2

        def build(self) -> "CustomTagsModel2":
            return CustomTagsModel2(**self._attrs)

        @overload
        def environment(
            self, value_or_callback: Optional[Environment], /
        ) -> "CustomTagsModel2.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "CustomTagsModel2.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment adds the value of an environment variable to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        @overload
        def header(self, value_or_callback: Header, /) -> "CustomTagsModel2.Builder": ...

        @overload
        def header(
            self,
            value_or_callback: Callable[[Header.Builder], Header.Builder | Header],
            /,
        ) -> "CustomTagsModel2.Builder": ...

        @overload
        def header(self, value_or_callback: Never = ...) -> "Header.BuilderContext": ...

        def header(self, value_or_callback=None, /):
            """
            RequestHeader adds the value of an header from the request to each span.
            """
            if self._in_context and value_or_callback is None:
                context = Header.BuilderContext()
                context._parent_builder = self
                context._field_name = "header"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Header.builder())
                if isinstance(output, Header.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("header", value)

        @overload
        def literal(
            self, value_or_callback: Optional[LiteralModel], /
        ) -> "CustomTagsModel2.Builder": ...

        @overload
        def literal(
            self,
            value_or_callback: Callable[
                [LiteralModel.Builder], LiteralModel.Builder | LiteralModel
            ],
            /,
        ) -> "CustomTagsModel2.Builder": ...

        @overload
        def literal(self, value_or_callback: Never = ...) -> "LiteralModel.BuilderContext": ...

        def literal(self, value_or_callback=None, /):
            """
            Literal adds the same, hard-coded value to each span.
            """
            if self._in_context and value_or_callback is None:
                context = LiteralModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "literal"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LiteralModel.builder())
                if isinstance(output, LiteralModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("literal", value)

    class BuilderContext(BuilderContextBase["CustomTagsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomTagsModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomTagsModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomTagsModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomTagsModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment: Optional[Environment] = None
    """
    Environment adds the value of an environment variable to each span.
    """
    header: Header
    """
    RequestHeader adds the value of an header from the request to each span.
    """
    literal: Optional[LiteralModel] = None
    """
    Literal adds the same, hard-coded value to each span.
    """


class MatchModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel3"]:
            return MatchModel3

        def build(self) -> "MatchModel3":
            return MatchModel3(**self._attrs)

        def mode(
            self, value: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]], /
        ) -> Self:
            """
            This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.

            Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["MatchModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["CLIENT_AND_SERVER", "CLIENT", "SERVER"]] = None
    """
    This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.

    Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
    """


class Tracing(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tracing"]:
            return Tracing

        def build(self) -> "Tracing":
            return Tracing(**self._attrs)

        def custom_tags(
            self,
            value: Optional[
                Dict[
                    str,
                    Union[CustomTags, CustomTagsModel, CustomTagsModel1, CustomTagsModel2],
                ]
            ],
            /,
        ) -> Self:
            """
            Optional.
            """
            return self._set("custom_tags", value)

        def disable_span_reporting(self, value: Optional[bool], /) -> Self:
            """
            Controls span reporting.
            """
            return self._set("disable_span_reporting", value)

        @overload
        def match(self, value_or_callback: Optional[MatchModel3], /) -> "Tracing.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[[MatchModel3.Builder], MatchModel3.Builder | MatchModel3],
            /,
        ) -> "Tracing.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "MatchModel3.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Allows tailoring of behavior to specific conditions.
            """
            if self._in_context and value_or_callback is None:
                context = MatchModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel3.builder())
                if isinstance(output, MatchModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def providers(self, value_or_callback: List[Provider], /) -> "Tracing.Builder": ...

        @overload
        def providers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Provider, Provider.Builder]],
                GenericListBuilder[Provider, Provider.Builder] | List[Provider],
            ],
            /,
        ) -> "Tracing.Builder": ...

        @overload
        def providers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Provider.Builder]: ...

        def providers(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Provider.Builder]()
                context._parent_builder = self
                context._field_name = "providers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Provider.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("providers", value)

        def random_sampling_percentage(self, value: Optional[float], /) -> Self:
            """
            Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
            """
            return self._set("random_sampling_percentage", value)

        def use_request_id_for_trace_sampling(self, value: Optional[bool], /) -> Self:
            return self._set("use_request_id_for_trace_sampling", value)

    class BuilderContext(BuilderContextBase["Tracing.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tracing.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tracing."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tracing", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tracing.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    custom_tags: Annotated[
        Optional[
            Dict[
                str,
                Union[CustomTags, CustomTagsModel, CustomTagsModel1, CustomTagsModel2],
            ]
        ],
        Field(alias="customTags"),
    ] = None
    """
    Optional.
    """
    disable_span_reporting: Annotated[Optional[bool], Field(alias="disableSpanReporting")] = None
    """
    Controls span reporting.
    """
    match: Optional[MatchModel3] = None
    """
    Allows tailoring of behavior to specific conditions.
    """
    providers: Optional[List[Provider]] = None
    """
    Optional.
    """
    random_sampling_percentage: Annotated[
        Optional[float], Field(alias="randomSamplingPercentage", ge=0.0, le=100.0)
    ] = None
    """
    Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
    """
    use_request_id_for_trace_sampling: Annotated[
        Optional[bool], Field(alias="useRequestIdForTraceSampling")
    ] = None


class TelemetrySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TelemetrySpec"]:
            return TelemetrySpec

        def build(self) -> "TelemetrySpec":
            return TelemetrySpec(**self._attrs)

        @overload
        def access_logging(
            self, value_or_callback: List[AccessLogging], /
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def access_logging(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AccessLogging, AccessLogging.Builder]],
                GenericListBuilder[AccessLogging, AccessLogging.Builder] | List[AccessLogging],
            ],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def access_logging(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AccessLogging.Builder]: ...

        def access_logging(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AccessLogging.Builder]()
                context._parent_builder = self
                context._field_name = "access_logging"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessLogging.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_logging", value)

        @overload
        def metrics(self, value_or_callback: List[Metric], /) -> "TelemetrySpec.Builder": ...

        @overload
        def metrics(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Metric, Metric.Builder]],
                GenericListBuilder[Metric, Metric.Builder] | List[Metric],
            ],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def metrics(self, value_or_callback: Never = ...) -> ListBuilderContext[Metric.Builder]: ...

        def metrics(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Metric.Builder]()
                context._parent_builder = self
                context._field_name = "metrics"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metric.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metrics", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "TelemetrySpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        @overload
        def target_ref(
            self, value_or_callback: Optional[TargetRef], /
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def target_ref(
            self,
            value_or_callback: Callable[[TargetRef.Builder], TargetRef.Builder | TargetRef],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def target_ref(self, value_or_callback: Never = ...) -> "TargetRef.BuilderContext": ...

        def target_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.builder())
                if isinstance(output, TargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_ref", value)

        @overload
        def target_refs(self, value_or_callback: List[TargetRef], /) -> "TelemetrySpec.Builder": ...

        @overload
        def target_refs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetRef, TargetRef.Builder]],
                GenericListBuilder[TargetRef, TargetRef.Builder] | List[TargetRef],
            ],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def target_refs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetRef.Builder]: ...

        def target_refs(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetRef.Builder]()
                context._parent_builder = self
                context._field_name = "target_refs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_refs", value)

        @overload
        def tracing(self, value_or_callback: List[Tracing], /) -> "TelemetrySpec.Builder": ...

        @overload
        def tracing(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Tracing, Tracing.Builder]],
                GenericListBuilder[Tracing, Tracing.Builder] | List[Tracing],
            ],
            /,
        ) -> "TelemetrySpec.Builder": ...

        @overload
        def tracing(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Tracing.Builder]: ...

        def tracing(self, value_or_callback=None, /):
            """
            Optional.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Tracing.Builder]()
                context._parent_builder = self
                context._field_name = "tracing"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tracing.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tracing", value)

    class BuilderContext(BuilderContextBase["TelemetrySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TelemetrySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TelemetrySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TelemetrySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TelemetrySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_logging: Annotated[Optional[List[AccessLogging]], Field(alias="accessLogging")] = None
    """
    Optional.
    """
    metrics: Optional[List[Metric]] = None
    """
    Optional.
    """
    selector: Optional[Selector] = None
    """
    Optional.
    """
    target_ref: Annotated[Optional[TargetRef], Field(alias="targetRef")] = None
    target_refs: Annotated[Optional[List[TargetRef]], Field(alias="targetRefs", max_length=16)] = (
        None
    )
    """
    Optional.
    """
    tracing: Optional[List[Tracing]] = None
    """
    Optional.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Unique, one-word, CamelCase reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is the type of the condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    Last time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    Last time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    Unique, one-word, CamelCase reason for the condition's last transition.
    """
    status: Optional[str] = None
    """
    Status is the status of the condition.
    """
    type: Optional[str] = None
    """
    Type is the type of the condition.
    """


class MessageType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MessageType"]:
            return MessageType

        def build(self) -> "MessageType":
            return MessageType(**self._attrs)

        def code(self, value: Optional[str], /) -> Self:
            """
            A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
            """
            return self._set("code", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            A human-readable name for the message type.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["MessageType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MessageType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MessageType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MessageType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MessageType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    code: Optional[str] = None
    """
    A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message type.
    """
    name: Optional[str] = None
    """
    A human-readable name for the message type.
    """


class ValidationMessage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValidationMessage"]:
            return ValidationMessage

        def build(self) -> "ValidationMessage":
            return ValidationMessage(**self._attrs)

        def documentation_url(self, value: Optional[str], /) -> Self:
            """
            A url pointing to the Istio documentation for this specific error type.
            """
            return self._set("documentation_url", value)

        def level(self, value: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]], /) -> Self:
            """
            Represents how severe a message is.

            Valid Options: UNKNOWN, ERROR, WARNING, INFO
            """
            return self._set("level", value)

        @overload
        def type(
            self, value_or_callback: Optional[MessageType], /
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(
            self,
            value_or_callback: Callable[[MessageType.Builder], MessageType.Builder | MessageType],
            /,
        ) -> "ValidationMessage.Builder": ...

        @overload
        def type(self, value_or_callback: Never = ...) -> "MessageType.BuilderContext": ...

        def type(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MessageType.BuilderContext()
                context._parent_builder = self
                context._field_name = "type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MessageType.builder())
                if isinstance(output, MessageType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ValidationMessage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValidationMessage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValidationMessage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValidationMessage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValidationMessage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    documentation_url: Annotated[Optional[str], Field(alias="documentationUrl")] = None
    """
    A url pointing to the Istio documentation for this specific error type.
    """
    level: Optional[Literal["UNKNOWN", "ERROR", "WARNING", "INFO"]] = None
    """
    Represents how severe a message is.

    Valid Options: UNKNOWN, ERROR, WARNING, INFO
    """
    type: Annotated[
        Optional[MessageType],
        Field(title="cloudcoil.models.istio.telemetry.v1.MessageType"),
    ] = None


class TelemetryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TelemetryStatus"]:
            return TelemetryStatus

        def build(self) -> "TelemetryStatus":
            return TelemetryStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "TelemetryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "TelemetryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Current service state of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Resource Generation to which the Reconciled Condition refers.
            """
            return self._set("observed_generation", value)

        @overload
        def validation_messages(
            self, value_or_callback: List[ValidationMessage], /
        ) -> "TelemetryStatus.Builder": ...

        @overload
        def validation_messages(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValidationMessage, ValidationMessage.Builder]],
                GenericListBuilder[ValidationMessage, ValidationMessage.Builder]
                | List[ValidationMessage],
            ],
            /,
        ) -> "TelemetryStatus.Builder": ...

        @overload
        def validation_messages(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationMessage.Builder]: ...

        def validation_messages(self, value_or_callback=None, /):
            """
            Includes any errors or warnings detected by Istio's analyzers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationMessage.Builder]()
                context._parent_builder = self
                context._field_name = "validation_messages"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationMessage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_messages", value)

    class BuilderContext(BuilderContextBase["TelemetryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TelemetryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TelemetryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TelemetryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TelemetryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Current service state of the resource.
    """
    observed_generation: Annotated[Optional[Union[int, str]], Field(alias="observedGeneration")] = (
        None
    )
    """
    Resource Generation to which the Reconciled Condition refers.
    """
    validation_messages: Annotated[
        Optional[List[ValidationMessage]], Field(alias="validationMessages")
    ] = None
    """
    Includes any errors or warnings detected by Istio's analyzers.
    """


class Telemetry(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Telemetry"]:
            return Telemetry

        def build(self) -> "Telemetry":
            return Telemetry(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[TelemetrySpec], /) -> "Telemetry.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [TelemetrySpec.Builder], TelemetrySpec.Builder | TelemetrySpec
            ],
            /,
        ) -> "Telemetry.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TelemetrySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TelemetrySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TelemetrySpec.builder())
                if isinstance(output, TelemetrySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[TelemetryStatus], /
        ) -> "Telemetry.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [TelemetryStatus.Builder], TelemetryStatus.Builder | TelemetryStatus
            ],
            /,
        ) -> "Telemetry.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "TelemetryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TelemetryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TelemetryStatus.builder())
                if isinstance(output, TelemetryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["telemetry.istio.io/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Telemetry"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Telemetry.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Telemetry.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Telemetry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Telemetry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Telemetry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Telemetry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Telemetry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[TelemetrySpec] = None
    status: Optional[TelemetryStatus] = None
    api_version: Annotated[
        Optional[Literal["telemetry.istio.io/v1"]], Field(alias="apiVersion")
    ] = "telemetry.istio.io/v1"
    kind: Optional[Literal["Telemetry"]] = "Telemetry"
    metadata: Optional[apimachinery.ObjectMeta] = None
